›Topic: ASM/ADDR››Summary of Address Modes››‘’’’’’’’’’’’’’’’’’’’’’’’’…›ü Áããõíõìáôïò Áääòåóóéîç ü›š’’’’’’’’’’’’’’’’’’’’’’’’ƒ››A one-byte instruction on the ›accumulator. The address is A.››Example:   Machine   Assembly›          ›          |6A       |ROR A     |›          ››Note: Some assemblers do not require›the "A" in the Assembly code. Others›do.››››‘’’’’’’’’’’’’’’’’’’’’…›ü Éíğìéåä Áääòåóóéîç ü›š’’’’’’’’’’’’’’’’’’’’ƒ››The address containing the operand is›implicitely stated in the instruction.››Example:   ›› Reg Val   Machine   Assembly›  ›| A |--|  |8A       |TXA       |›| X |42|  ›| Y |--|   A=$42  ››››››››‘’’’’’’’’’’’…›ü Éííåäéáôå ü›š’’’’’’’’’’’ƒ››The operand is found in the 2nd byte›of the instruction.››Example:›           Machine   Assembly›          ›          |A9 42    |LDA #$42  |›          ›           A=$42››››››››››‘’’’’’’’’’’…›ü Áâóïìõôå ü›š’’’’’’’’’’ƒ››The address of the operand is found›in the 2nd and 3rd bytes of the ›instruction. Low-byte first.››Example:›› Addr Val  Machine   Assembly› ›|0537|--| |AD 38 05 |LDA $0538 |›|0538|42|    ›|0539|--|  A=$42››››››››‘’’’’’’’’’’’’’’’’’’’’’’’’…›ü Áâóïìõôå Éîäåøåä ¨Ø¬Ù© ü›š’’’’’’’’’’’’’’’’’’’’’’’’ƒ››The address of the operand is derived›by adding the contents of the X or Y›register to the address given in the›2nd and 3rd bytes of the instruction. ››Example:›› Addr Val  Machine   Assembly› ›|0537|--| |BD 38 05 |LDA $0538,X |›|0538|42| ›|0539|45|›|053A|52|  If X=0, A=$42›|053B|--|  If X=1, A=$45›  If X=2, A=$52›           and so on...››‘’’’’’’’’’’’…›ü Úåòï Ğáçå ü›š’’’’’’’’’’’ƒ››Similar to Absolute Addressing, but›the operand's address is assumed to›be in page zero, so only the›low-byte is needed and the high-byte›is implicitly $00.››Example:›› Addr Val  Machine   Assembly› ›|0037|--| |A5 38    |LDA $38   |›|0038|42|    ›|0039|--|  A=$42››››››‘’’’’’’’’’’’’’’’’’’’’’’’’’…›ü Úåòï Ğáçå Éîäåøåä ¨Ø¬Ù© ü›š’’’’’’’’’’’’’’’’’’’’’’’’’ƒ››Similar to Absolute Indexed, but the›address to the operand is derived by›adding the contents of the X or Y›register to the zero page address ›given in the 2nd byte of the›instruction.››Example:›› Addr Val  Machine   Assembly› ›|0037|--| |B5 38    |LDA $38,X   |›|0038|42| ›|0039|45|›|003A|52|  If X=0, A=$42›|003B|--|  If X=1, A=$45›  If X=2, A=$52, and so on..›››‘’’’’’’’’’’’’’’’’’’’…›ü Áâóïìõôå Éîäéòåãô ü›š’’’’’’’’’’’’’’’’’’’ƒ››In the 6502, only the JMP instruction›uses this mode. ››The 2nd and 3rd bytes of the ›instruction point to an address which›contains the address to be jumped.››Example:›› Addr Val  Machine   Assembly› ›|0537|--| |6C 38 05 |JMP ($0538) |›|0538|42| ›|0539|30|›|053A|--| The program will jump to ›|    |  | to address $3042.  ›|3041|--|›|3042|--|  Jump to here›|3043|--|›› ›‘’’’’’’’’’’’’’’’’’’’’’’…›ü Éîäéòåãô Éîäåøåä ¨Ù© ü›š’’’’’’’’’’’’’’’’’’’’’’ƒ››The 2nd byte of the instruction ›is a zero page address which points›to a base address. The Y index›is added to this base address to ›locate the operand.›››Example:›› Addr Val  Machine   Assembly› ›|0037|--| |B1 38    |LDA ($38),Y |›|0038|46| ›|0039|A0|›|003A|--| If Y=0, A=$42›|    |  | If Y=1, A=$45   ›|A045|--| If Y=2, A=$52›|A046|42| and so on... ›|A047|45|›|A048|52|›|A049|--|›››‘’’’’’’’’’’’’’’’’’’’’’’…›ü Éîäåøåä Éîäéòåãô ¨Ø© ü›š’’’’’’’’’’’’’’’’’’’’’’ƒ››The 2nd byte of the instruction ›points to a zero page base address.›The X register is used to offset from›this base address. The contents of›the offset address points to the ›address of the operand.››Example:›› Addr Val  Machine   Assembly› ›|0037|--| |B1 38    |LDA ($38,X) |›|0038|44| ›|0039|A0|›|003A|33| If X=0, A=$42›|003B|B0| If X=2, A=$45›|003C|22| If X=4, A=$52›|003D|C0|›|003E|--|›|    |  | ›|A043|xx|›|A044|42|›|A045|xx|›|    |  |›|B032|--|›|B033|45|›|B034|--|›|    |  |›|C021|--|›|C022|52|›|C023|--|›››‘’’’’’’’’’’…›ü Òåìáôéöå ü›š’’’’’’’’’’ƒ››This mode is exclusive to branch›instructions and derives a jump›destination if the condition is true.››The 2nd byte of the instruction is›added to the Program Counter when the›counter is set at the next›instruction.››The range is -128 to +127 from the ›next instruction.››Example:›› Addr Val  Machine   Assembly› ›|0600|--| |F0 02    |BEQ $02 |›|0601|F0| ›|0602|02|›|0603|--| If Z=1, jump to $0603+$02›|0604|--|›|0605|60|  Jump to here ›|0606|--|›››In practice, a label will be provided›by the programmer in lieu of a›physical jump offset. The assembler›will derive the Program Counter›offset using the labels and the›assembled addresses.››