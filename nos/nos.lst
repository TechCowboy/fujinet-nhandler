mads 2.1.5
Source: nos.s
     1 				        
     2 				        ;; Compile with MADS
     3
     4 				        ;; Authors: Thomas Cherryhomes
     5 				        ;;   <thom.cherryhomes@gmail.com>
     6
     7 				        ;; Michael Sternberg
     8 				        ;;   <mhsternberg@gmail.com>
     9
    10
    11 				        ;; Optimizations being done by djaybee!
    12 				        ;; Thank you so much!
    13
    14
    15 = 000A			DOSVEC  =   $0A         ; DOSVEC
    16 = 000C			DOSINI  =   $0C         ; DOSINI
    17
    18 				        ;; CURRENT IOCB IN ZERO PAGE
    19 = 0020			ZIOCB   =   $20         ; ZP IOCB
    20 = 0020			ZICHID  =   ZIOCB       ; ID
    21 = 0021			ZICDNO  =   ZIOCB+1     ; UNIT #
    22 = 0022			ZICCOM  =   ZIOCB+2     ; COMMAND
    23 = 0023			ZICSTA  =   ZIOCB+3     ; STATUS
    24 = 0024			ZICBAL  =   ZIOCB+4     ; BUF ADR LOW
    25 = 0025			ZICBAH  =   ZIOCB+5     ; BUF ADR HIGH
    26 = 0026			ZICPTL  =   ZIOCB+6     ; PUT ADDR L
    27 = 0027			ZICPTH  =   ZIOCB+7     ; PUT ADDR H
    28 = 0028			ZICBLL  =   ZIOCB+8     ; BUF LEN LOW
    29 = 0029			ZICBLH  =   ZIOCB+9     ; BUF LEN HIGH
    30 = 002A			ZICAX1  =   ZIOCB+10    ; AUX 1
    31 = 002B			ZICAX2  =   ZIOCB+11    ; AUX 2
    32 = 002C			ZICAX3  =   ZIOCB+12    ; AUX 3
    33 = 002D			ZICAX4  =   ZIOCB+13    ; AUX 4
    34 = 002E			ZICAX5  =   ZIOCB+14    ; AUX 5
    35 = 002F			ZICAX6  =   ZIOCB+15    ; AUX 6
    36
    37 = 0052			LMARGN  =   $52         ; Left margin
    38 = 00D4			FR0     =   $D4         ; Floating Point register 0 (used during Hex->ASCII conversion)
    39 = 00F2			CIX     =   $F2         ; Inbuff cursor
    40 = 00F3			INBUFF  =   $F3         ; Ptr to input buffer ($0580)
    41 = 0040			MAX_APPKEY_LEN = $40    ; Used with appkey files
    42
    43 				;---------------------------------------
    44 				; INTERRUPT VECTORS
    45 				; AND OTHER PAGE 2 VARS
    46 				;---------------------------------------
    47
    48 = 0202			VPRCED  =   $0202       ; PROCEED VCTR
    49 = 02C6			COLOR2  =   $02C6       ; MODEF BKG C
    50 = 02E0			RUNAD   =   $02E0       ; RUN ADDRESS
    51 = 02E2			INITAD  =   $02E2       ; INIT ADDRESS
    52 = 02E7			MEMLO   =   $02E7       ; MEM LO
    53 = 02EA			DVSTAT  =   $02EA       ; 4 BYTE STATS
    54
    55 				;---------------------------------------
    56 				; PAGE 3
    57 				; DEVICE CONTROL BLOCK (DCB)
    58 				;---------------------------------------
    59
    60 = 0300			DCB     =   $0300       ; BASE
    61 = 0300			DDEVIC  =   DCB         ; DEVICE #
    62 = 0301			DUNIT   =   DCB+1       ; UNIT #
    63 = 0302			DCOMND  =   DCB+2       ; COMMAND
    64 = 0303			DSTATS  =   DCB+3       ; STATUS/DIR
    65 = 0304			DBUFL   =   DCB+4       ; BUF ADR L
    66 = 0305			DBUFH   =   DCB+5       ; BUF ADR H
    67 = 0306			DTIMLO  =   DCB+6       ; TIMEOUT (S)
    68 = 0307			DRSVD   =   DCB+7       ; NOT USED
    69 = 0308			DBYTL   =   DCB+8       ; BUF LEN L
    70 = 0309			DBYTH   =   DCB+9       ; BUF LEN H
    71 = 030A			DAUXL   =   DCB+10      ; AUX BYTE L
    72 = 030B			DAUXH   =   DCB+11      ; AUX BYTE H
    73
    74 = 031A			HATABS  =   $031A       ; HANDLER TBL
    75
    76 				;---------------------------------------
    77 				; IOCB'S * 8
    78 				;---------------------------------------
    79
    80 = 0340			IOCB    =   $0340       ; IOCB BASE
    81 = 0340			ICHID   =   IOCB        ; ID
    82 = 0341			ICDNO   =   IOCB+1      ; UNIT #
    83 = 0342			ICCOM   =   IOCB+2      ; COMMAND
    84 = 0343			ICSTA   =   IOCB+3      ; STATUS
    85 = 0344			ICBAL   =   IOCB+4      ; BUF ADR LOW
    86 = 0345			ICBAH   =   IOCB+5      ; BUF ADR HIGH
    87 = 0346			ICPTL   =   IOCB+6      ; PUT ADDR L
    88 = 0347			ICPTH   =   IOCB+7      ; PUT ADDR H
    89 = 0348			ICBLL   =   IOCB+8      ; BUF LEN LOW
    90 = 0349			ICBLH   =   IOCB+9      ; BUF LEN HIGH
    91 = 034A			ICAX1   =   IOCB+10     ; AUX 1
    92 = 034B			ICAX2   =   IOCB+11     ; AUX 2
    93 = 034C			ICAX3   =   IOCB+12     ; AUX 3
    94 = 034D			ICAX4   =   IOCB+13     ; AUX 4
    95 = 034E			ICAX5   =   IOCB+14     ; AUX 5
    96 = 034F			ICAX6   =   IOCB+15     ; AUX 6
    97
    98 = 0054			ROWCRS  =   $0054
    99 = 02BB			SCRFLG  =   $02BB       ; Scroll flag
   100 = 02FC			CH      =   $02FC       ; Hardware code for last key pressed
   101 = 02F2			CH1     =   $02F2       ; Prior keyboard character code
   102 = 0582			LNBUF   =   $0582       ; Line Buffer (128 bytes)
   103 				;LNBUF   =   $1880       ; Line Buffer (128 bytes)
   104
   105 				;---------------------------------------
   106 				; HARDWARE REGISTERS
   107 				;---------------------------------------
   108
   109 = D01F			CONSOL  =   $D01F       ; Console switches
   110 = D301			PORTB   =   $D301       ; On XL/XE, used to enable/disable BASIC
   111 = D302			PACTL   =   $D302       ; PIA CTRL A
   112
   113 				;---------------------------------------
   114 				; MATH PACK VECTORS
   115 				;---------------------------------------
   116 = D8E6			FASC    =   $D8E6       ; Floating point to ASCII
   117 = D9AA			IFP     =   $D9AA       ; Integer to floating point
   118
   119 				;---------------------------------------
   120 				; OS ROM VECTORS
   121 				;---------------------------------------
   122
   123 = E456			CIOV    =   $E456       ; CIO ENTRY
   124 = E459			SIOV    =   $E459       ; SIO ENTRY
   125 = E474			WARMSV  =   $E474       ; Warmstart entry point
   126 = E477			COLDSV  =   $E477       ; Coldstart entry point
   127
   128 				;---------------------------------------
   129 				; CONSTANTS
   130 				;---------------------------------------
   131
   132 = 0005			GETREC  =   $05         ; CIO CMD TO GET RECORD
   133 = 0009			PUTREC  =   $09         ; CIO CMD TO PUT RECORD
   134 = 000B			PUTCHR  =   $0B         ; CIO CMD TO PUT CHAR
   135
   136 = 0071			DEVIDN  =   $71         ; SIO DEVID
   137 = 0040			DSREAD  =   $40         ; FUJI->ATARI
   138 = 0080			DSWRIT  =   $80         ; ATARI->FUJI
   139 = 0004			MAXDEV  =   4           ; # OF N: DEVS
   140 = 0088			EOF     =   $88         ; ERROR 136
   141
   142 = 009B			EOL     =   $9B         ; EOL CHAR
   143 = 000D			CR      =   $0D         ; Carrige Return
   144 = 000A			LF      =   $0A         ; Linefeed
   145
   146 = 0003			OPTION  =   $03
   147 = 001C			ESC_KEY =   $1C         ; Hardware code for ESC
   148 = 0021			SPC_KEY =   $21         ; Hardware code for SPACE
   149
   150 = 0004			OINPUT  =   $04         ; CIO/SIO direction
   151 = 0008			OOUTPUT =   $08         ; CIO/SIO direction
   152 = 00F0			BOGUS   =   $F0         ; Bogus FujiNet SIO command byte
   153
   154 				; FujiNet SIO command bytes.
   155 = 0001			CMD_DRIVE_CHG       = $01
   156 = 002C			CMD_CD              = $2C
   157 				;CMD_COPY            = $A1
   158 = 0002			CMD_DIR             = $02
   159 = 0021			CMD_DEL             = $21
   160 = 0028			CMD_LOAD            = $28
   161 				;CMD_LOCK            = $23
   162 = 00F0			CMD_LPR             = BOGUS
   163 = 002A			CMD_MKDIR           = $2A
   164 = 0030			CMD_NPWD            = $30
   165 = 0054			CMD_NTRANS          = 'T'
   166 = 00FE			CMD_PASS            = $FE
   167 = 0020			CMD_RENAME          = $20
   168 = 002B			CMD_RMDIR           = $2B
   169 = 00F0			CMD_SUBMIT          = BOGUS
   170 = 00F0			CMD_TYPE            = BOGUS
   171 = 00FD			CMD_USER            = $FD
   172 				;CMD_UNLOCK          = $24
   173 = 00F0			CMD_CAR             = BOGUS
   174 = 00F0			CMD_CLS             = BOGUS
   175 = 00F0			CMD_COLD            = BOGUS
   176 = 00F0			CMD_HELP            = BOGUS
   177 = 00F0			CMD_NOBASIC         = BOGUS
   178 = 00F0			CMD_NOSCREEN        = BOGUS
   179 = 00F0			CMD_PRINT           = BOGUS
   180 = 00F0			CMD_REENTER         = BOGUS
   181 = 00F0			CMD_REM             = BOGUS
   182 = 00F0			CMD_RUN             = BOGUS
   183 = 00F0			CMD_SCREEN          = BOGUS
   184 = 00F0			CMD_WARM            = BOGUS
   185 = 00F0			CMD_XEP             = BOGUS
   186 = 00F0			CMD_AUTORUN         = BOGUS
   187
   188 				;;; Macros ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   189
   190 				        .MACRO DCBC
   191 				        .LOCAL
   192 				        LDY     #$0C
   193 				?DCBL   LDA     %%1,Y
   194 				        STA     DCB,Y
   195 				        DEY
   196 				        BPL     ?DCBL
   197 				        .ENDL
   198 				        .ENDM
   199
   200 				; ATR Header
   201 					    ORG	    $06f0
   202 				        OPT     h-
   203 06F0 96 02 80 16 80		    DTA	    $96,$02,$80,$16,$80
   204 06F5 00 00 00 00 00 00 + :11     DTA	    $00
   205
   206 				;;; Initialization ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   207
   208 0700 00			HDR:    .BYTE   $00                 ; BLFAG: Boot flag equals zero (unused)
   209 0701 22			        .BYTE   [BOOTEND-HDR]/128   ; BRCNT: Number of consecutive sectors to read
   210 0702 00 07		        .WORD   HDR                 ; BLDADR: Boot sector load address ($700).
   211 0704 C0 E4		        .WORD   $E4C0               ; BIWTARR: Init addr (addr of RTS in ROM)
   212
   213 0706 4C 09 07			    JMP	    START
   214
   215 0709 A5 0C		START:  LDA     DOSINI
   216 070B 8D 27 07		        STA     RESET+1
   217 070E A5 0D		        LDA     DOSINI+1
   218 0710 8D 28 07		        STA     RESET+2
   219
   220 0713 A9 26		        LDA     #<RESET
   221 0715 85 0C		        STA     DOSINI
   222 0717 A9 07		        LDA     #>RESET
   223 0719 85 0D		        STA     DOSINI+1
   224 071B A9 DC		        LDA     #<DOS       ; Point to DOS & CP below
   225 071D 85 0A		        STA     DOSVEC
   226 071F A9 0A		        LDA     #>DOS
   227 0721 85 0B		        STA     DOSVEC+1
   228
   229 0723 4C 39 07		        JMP     ALTMEML     ; Alter MEMLO
   230
   231 0726 20 FF FF		RESET:  JSR     $FFFF       ; Jump to extant DOSINI
   232
   233 0729 A9 4E		        LDA     #'N'
   234 072B 8D 00 18		        STA     RBUF
   235 072E 20 44 07		        JSR     IHTBS       ; Insert into HATABS
   236
   237 0731 A9 44		        LDA     #'D'
   238 0733 8D 00 18		        STA     RBUF
   239 0736 20 44 07		        JSR     IHTBS       ; Clone N: as D: for compatibility
   240
   241 				;---------------------------------------
   242 				;  Alter MEMLO
   243 				;---------------------------------------
   244 0739			ALTMEML:
   245 0739 A9 00		        LDA     #<PGEND
   246 073B 8D E7 02		        STA     MEMLO
   247 073E A9 19		        LDA     #>PGEND
   248 0740 8D E8 02		        STA     MEMLO+1
   249
   250 				        ;; Back to DOS
   251
   252 0743 60			        RTS
   253
   254 				;---------------------------------------
   255 				; Insert entry into HATABS
   256 				;---------------------------------------
   257
   258 0744			IHTBS:
   259 0744 A0 00		        LDY     #$00
   260 0746 B9 1A 03		IH1     LDA     HATABS,Y
   261 0749 F0 0C		        BEQ     HFND
   262 074B CD 00 18		        CMP     RBUF        ; RBUF contains 'N' or 'D'
   263 074E F0 07		        BEQ     HFND
   264 0750 C8			        INY
   265 0751 C8			        INY
   266 0752 C8			        INY
   267 0753 C0 21		        CPY     #11*3
   268 0755 90 EF		        BCC     IH1
   269
   270 				        ;; Found a slot
   271
   272 0757			HFND:
   273 0757 AD 00 18		        LDA     RBUF        ; RBUF contains 'N' or 'D'
   274 075A AA			        TAX
   275 075B 99 1A 03		        STA     HATABS,Y
   276 075E A9 11		        LDA     #<CIOHND
   277 0760 99 1B 03		        STA     HATABS+1,Y
   278 0763 A9 17		        LDA     #>CIOHND
   279 0765 99 1C 03		        STA     HATABS+2,Y
   280
   281 0768 E0 44		        CPX     #'D'
   282 076A F0 01		        BEQ     HATABS_CONT
   283 076C 60			        RTS
   284
   285 076D			HATABS_CONT:
   286 				        ;; And we're done with HATABS
   287
   288 				        ;; Query FUJINET
   289
   290 076D 20 24 09		        JSR     STPOLL
   291
   292 				        ;; Output Ready/Error
   293
   294 0770			OBANR:
   295 0770 A2 00		        LDX     #$00        ; IOCB #0
   296 0772 A9 09		        LDA     #PUTREC
   297 0774 9D 42 03		        STA     ICCOM,X
   298 0777 A9 28		        LDA     #$28        ; 40 CHARS Max
   299 0779 9D 48 03		        STA     ICBLL,X
   300 077C 8A			        TXA
   301 077D 9D 49 03		        STA     ICBLH,X
   302 0780 AD 03 03		        LDA     DSTATS      ; Check DSTATS
   303 0783 10 06		        BPL     OBRDY       ; < 128 = Ready
   304
   305 				        ;; Status returned error.
   306
   307 0785			OBERR:
   308 0785 A9 37		        LDA     #<BERROR
   309 0787 A0 17		        LDY     #>BERROR
   310 0789 50 04		        BVC     OBCIO
   311
   312 				        ;; Status returned ready.
   313
   314 078B			OBRDY:
   315 078B A9 1D		        LDA     #<BREADY
   316 078D A0 17		        LDY     #>BREADY
   317
   318 078F			OBCIO:
   319 078F 9D 44 03		        STA     ICBAL,X
   320 0792 98			        TYA
   321 0793 9D 45 03		        STA     ICBAH,X
   322
   323 0796 20 56 E4		        JSR     CIOV
   324
   325 				        ;; Vector in proceed interrupt
   326
   327 0799			SPRCED:
   328 0799 A9 6B		        LDA     #<PRCVEC
   329 079B 8D 02 02		        STA     VPRCED
   330 079E A9 0A		        LDA     #>PRCVEC
   331 07A0 8D 03 02		        STA     VPRCED+1
   332
   333 				        ;; And we are done, back to DOS.
   334 07A3 18			        CLC
   335 07A4 60			        RTS
   336
   337 				;;; End Initialization Code ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   338
   339 				; Copy command's template DCB struct to OS's DCB struct (12 bytes)
   340 07A5			DOSIOV:
   341 07A5 8D AE 07		        STA     DODCBL+1
   342 07A8 8C AF 07		        STY     DODCBL+2
   343 07AB A0 0C		        LDY     #$0C
   344 07AD B9 FF FF		DODCBL  LDA     $FFFF,Y
   345 07B0 99 00 03		        STA     DCB,Y
   346 07B3 88			        DEY
   347 07B4 10 F7		        BPL     DODCBL
   348
   349 07B6			SIOVDST:
   350 07B6 20 59 E4		        JSR     SIOV
   351 07B9 AC 03 03		        LDY     DSTATS
   352 07BC 98			        TYA
   353 07BD 60			        RTS
   354
   355
   356 				;---------------------------------------
   357 				; CIO OPEN
   358 				;---------------------------------------
   359
   360 07BE			OPEN:
   361 				        ;; Prepare DCB
   362
   363 07BE 20 5C 0A		        JSR     GDIDX       ; Get Device ID in X (0-3)
   364 07C1 A5 21		        LDA     ZICDNO      ; IOCB UNIT # (1-4)
   365 07C3 8D 01 08		        STA     OPNDCB+1    ; Store in DUNIT
   366 07C6 A5 24		        LDA     ZICBAL      ; Get filename buffer
   367 07C8 8D 04 08		        STA     OPNDCB+4    ; stuff in DBUF
   368 07CB A5 25		        LDA     ZICBAH      ; ...
   369 07CD 8D 05 08		        STA     OPNDCB+5    ; ...
   370 07D0 A5 2A		        LDA     ZICAX1      ; Get desired AUX1/AUX2
   371 07D2 8D 0A 08		        STA     OPNDCB+10   ; Save them, and store in DAUX1/DAUX2
   372 07D5 A5 2B		        LDA     ZICAX2      ; ...
   373 07D7 8D 0B 08		        STA     OPNDCB+11   ; ...
   374
   375 				        ;;  Copy DCB template to DCB
   376
   377 07DA A9 00		        LDA     #<OPNDCB
   378 07DC A0 08		        LDY     #>OPNDCB
   379
   380 				        ;;  Send to #FujiNet
   381
   382 07DE 20 A5 07		        JSR     DOSIOV
   383
   384 				        ;; Return DSTATS, unless 144, then get extended error
   385
   386 07E1			OPCERR:
   387 07E1 C0 90		        CPY     #$90        ; ERR 144?
   388 07E3 D0 06		        BNE     OPDONE      ; NOPE. RETURN DSTATS
   389
   390 				        ;; 144 - get extended error
   391
   392 07E5 20 24 09		        JSR     STPOLL      ; POLL FOR STATUS
   393 07E8 AC ED 02		        LDY     DVSTAT+3
   394
   395 				       ; RESET BUFFER LENGTH + OFFSET
   396
   397 07EB			OPDONE:
   398 07EB A9 01		        LDA     #$01
   399 07ED 8D 55 17		        STA     TRIP
   400 07F0 20 5C 0A		        JSR     GDIDX
   401 07F3 A9 00		        LDA     #$00
   402 07F5 9D 56 17		        STA     RLEN,X
   403 07F8 9D 5E 17		        STA     TOFF,X
   404 07FB 9D 5A 17		        STA     ROFF,X
   405 07FE 98			        TYA
   406 07FF 60			        RTS                ; AY = ERROR
   407
   408 0800			OPNDCB:
   409 0800 71			        .BYTE   DEVIDN  ; DDEVIC
   410 0801 FF			        .BYTE   $FF     ; DUNIT
   411 0802 4F			        .BYTE   'O'     ; DCOMND
   412 0803 80			        .BYTE   $80     ; DSTATS
   413 0804 FF			        .BYTE   $FF     ; DBUFL
   414 0805 FF			        .BYTE   $FF     ; DBUFH
   415 0806 0F			        .BYTE   $0F     ; DTIMLO
   416 0807 00			        .BYTE   $00     ; DRESVD
   417 0808 00			        .BYTE   $00     ; DBYTL
   418 0809 01			        .BYTE   $01     ; DBYTH
   419 080A FF			        .BYTE   $FF     ; DAUX1
   420 080B FF			        .BYTE   $FF     ; DAUX2
   421
   422 				; End CIO OPEN
   423 				;---------------------------------------
   424
   425 				;---------------------------------------
   426 				; CIO CLOSE 
   427 				;---------------------------------------
   428
   429 080C			CLOSE:
   430 080C 20 53 0A		        JSR     DIPRCD      ; Disable Interrupts
   431 080F 20 5C 0A		        JSR     GDIDX
   432 0812 20 AF 08		        JSR     PFLUSH      ; Do a Put Flush if needed.
   433
   434 0815 A5 21		        LDA     ZICDNO      ; IOCB Unit #
   435 0817 8D 22 08		        STA     CLODCB+1    ; to DCB...
   436
   437 081A A9 21		        LDA     #<CLODCB
   438 081C A0 08		        LDY     #>CLODCB
   439
   440 081E 4C A5 07		        JMP     DOSIOV
   441
   442 0821 71			CLODCB .BYTE    DEVIDN      ; DDEVIC
   443 0822 FF			       .BYTE    $FF         ; DUNIT
   444 0823 43			       .BYTE    'C'         ; DCOMND
   445 0824 00			       .BYTE    $00         ; DSTATS
   446 0825 00			       .BYTE    $00         ; DBUFL
   447 0826 00			       .BYTE    $00         ; DBUFH
   448 0827 0F			       .BYTE    $0F         ; DTIMLO
   449 0828 00			       .BYTE    $00         ; DRESVD
   450 0829 00			       .BYTE    $00         ; DBYTL
   451 082A 00			       .BYTE    $00         ; DBYTH
   452 082B 00			       .BYTE    $00         ; DAUX1
   453 082C 00			       .BYTE    $00         ; DAUX2
   454
   455 				; End CIO CLOSE
   456 				;---------------------------------------
   457
   458 				;---------------------------------------
   459 				; CIO GET
   460 				;---------------------------------------
   461
   462 082D 20 5C 0A		GET:    JSR     GDIDX       ; IOCB UNIT #-1 into X
   463 0830 BD 56 17		        LDA     RLEN,X      ; Get # of RX chars waiting
   464 0833 D0 2B		        BNE     GETDISC     ; LEN > 0?
   465
   466 				        ;; If RX buffer is empty, get # of chars waiting...
   467
   468 0835 20 24 09		        JSR     STPOLL      ; Status Poll
   469 0838 20 5C 0A		        JSR     GDIDX       ; IOCB UNIT -1 into X (because Poll trashes X)
   470 083B AD EA 02		        LDA     DVSTAT      ; # of bytes waiting (0-127)
   471 083E 9D 56 17		        STA     RLEN,X      ; Store in RX Len
   472 0841 F0 22		        BEQ     RETEOF
   473
   474 0843 A5 21		GETDO:  LDA     ZICDNO      ; Get IOCB UNIT #
   475 0845 8D 83 08		        STA     GETDCB+1    ; Store into DUNIT
   476 0848 AD EA 02		        LDA     DVSTAT      ; # of bytes waiting
   477 084B 8D 8A 08		        STA     GETDCB+8    ; Store into DBYT...
   478 084E 8D 8C 08		        STA     GETDCB+10   ; and DAUX1...
   479
   480 0851 A9 82		        LDA     #<GETDCB
   481 0853 A0 08		        LDY     #>GETDCB
   482
   483 0855 20 A5 07		        JSR     DOSIOV
   484
   485 				        ;; Clear the Receive buffer offset.
   486
   487 0858 20 5C 0A		        JSR     GDIDX       ; IOCB UNIT #-1 into X
   488 085B A9 00		        LDA     #$00
   489 085D 9D 5A 17		        STA     ROFF,X
   490
   491 0860			GETDISC:
   492 				        ;LDA     DVSTAT+2    ; Did we disconnect?
   493 0860 AD ED 02		        LDA     DVSTAT+3    ; Did we disconnect?
   494 0863 D0 04		        BNE     GETUPDP     ; nope, update the buffer cursor.
   495
   496 				        ;; We disconnected, emit an EOF.
   497
   498 0865			RETEOF:
   499 0865 A0 88		        LDY     #EOF
   500 0867 98			        TYA
   501 0868 60			        RTS                 ; buh-bye.
   502
   503 0869			GETUPDP:
   504 0869 DE 56 17		        DEC     RLEN,X      ; Decrement RX length.
   505 086C BC 5A 17		        LDY     ROFF,X      ; Get RX offset cursor.
   506
   507 				        ;; Return Next char from appropriate RX buffer.
   508
   509 086F B9 00 18		        LDA     RBUF,Y
   510
   511 				        ;; Increment RX offset
   512
   513 0872 FE 5A 17		GX:     INC     ROFF,X      ; Increment RX offset.
   514 0875 A8			        TAY                 ; stuff returned val into Y temporarily.
   515
   516 				        ;; If requested RX buffer is empty, reset TRIP.
   517
   518 0876 BD 56 17		        LDA     RLEN,X
   519 0879 D0 03		        BNE     GETDONE
   520 087B 8D 55 17		        STA     TRIP
   521
   522 				        ;; Return byte back to CIO.
   523
   524 087E			GETDONE:
   525 087E 98			        TYA                 ; Move returned val back.
   526 087F A0 01		        LDY     #$01        ; SUCCESS
   527
   528 0881 60			        RTS                 ; DONE...
   529
   530 0882			GETDCB:
   531 0882 71			       .BYTE    DEVIDN      ; DDEVIC
   532 0883 FF			       .BYTE    $FF         ; DUNIT
   533 0884 52			       .BYTE    'R'         ; DCOMND
   534 0885 40			       .BYTE    $40         ; DSTATS
   535 0886 00			       .BYTE    <RBUF       ; DBUFL
   536 0887 18			       .BYTE    >RBUF       ; DBUFH
   537 0888 0F			       .BYTE    $0F         ; DTIMLO
   538 0889 00			       .BYTE    $00         ; DRESVD
   539 088A FF			       .BYTE    $FF         ; DBYTL
   540 088B 00			       .BYTE    $00         ; DBYTH
   541 088C FF			       .BYTE    $FF         ; DAUX1
   542 088D 00			       .BYTE    $00         ; DAUX2
   543
   544 				; End CIO GET
   545 				;---------------------------------------
   546
   547 				;---------------------------------------
   548 				; CIO PUT
   549 				;---------------------------------------
   550
   551 088E			PUT:    ;; Add to TX buffer.
   552
   553 088E 20 5C 0A		        JSR     GDIDX
   554 0891 BC 5E 17		        LDY     TOFF,X      ; GET TX cursor.
   555 0894 99 80 18		        STA     TBUF,Y      ; TX Buffer
   556
   557 0897 FE 5E 17		POFF:   INC     TOFF,X      ; Increment TX cursor
   558 089A A0 01		        LDY     #$01        ; SUCCESSFUL
   559
   560 				        ;; Do a PUT FLUSH if EOL or buffer full.
   561
   562 089C C9 9B		        CMP     #EOL        ; EOL?
   563 089E F0 0B		        BEQ     FLUSH       ; FLUSH BUFFER
   564 08A0 20 5C 0A		        JSR     GDIDX       ; GET OFFSET
   565 08A3 BD 5E 17		        LDA     TOFF,X
   566 08A6 C9 7F		        CMP     #$7F        ; LEN = $FF?
   567 08A8 F0 01		        BEQ     FLUSH       ; FLUSH BUFFER
   568 08AA 60			        RTS
   569
   570 				       ; FLUSH BUFFER, IF ASKED.
   571
   572 08AB 20 AF 08		FLUSH:  JSR     PFLUSH      ; FLUSH BUFFER
   573 08AE 60			        RTS
   574
   575 08AF			PFLUSH:
   576
   577 				       ; CHECK CONNECTION, AND EOF
   578 				       ; IF DISCONNECTED.
   579
   580 08AF 20 24 09		        JSR     STPOLL      ; GET STATUS
   581 08B2 AD ED 02		        LDA     DVSTAT+3
   582 08B5 F0 AE		        BEQ     RETEOF
   583
   584 08B7 20 5C 0A		PF1:    JSR     GDIDX       ; GET DEV X
   585 08BA BD 5E 17		        LDA     TOFF,X
   586 08BD D0 03		        BNE     PF2
   587 08BF 4C DF 08		        JMP     PDONE
   588
   589 				       ; FILL OUT DCB FOR PUT FLUSH
   590
   591 08C2 A5 21		PF2:    LDA     ZICDNO
   592 08C4 8D E3 08		        STA     PUTDCB+1
   593
   594 				       ; FINISH DCB AND DO SIOV
   595
   596 08C7 BD 5E 17		TBX:    LDA     TOFF,X
   597 08CA 8D EA 08		        STA     PUTDCB+8
   598 08CD 8D EC 08		        STA     PUTDCB+10
   599
   600 08D0 A9 E2		        LDA     #<PUTDCB
   601 08D2 A0 08		        LDY     #>PUTDCB
   602 08D4 20 A5 07		        JSR     DOSIOV
   603
   604 				        ; CLEAR THE OFFSET CURSOR
   605 				        ; AND LENGTH
   606
   607 08D7 20 5C 0A		        JSR     GDIDX
   608 08DA A9 00		        LDA     #$00
   609 08DC 9D 5E 17		        STA     TOFF,X
   610
   611 08DF A0 01		PDONE:  LDY     #$01
   612 08E1 60			        RTS
   613
   614 08E2 71			PUTDCB .BYTE    DEVIDN      ; DDEVIC
   615 08E3 FF			       .BYTE    $FF         ; DUNIT
   616 08E4 57			       .BYTE    'W'         ; DCOMND
   617 08E5 80			       .BYTE    $80         ; DSTATS
   618 08E6 80			       .BYTE    $80         ; DBUFL
   619 08E7 18			       .BYTE    >TBUF       ; DBUFH
   620 08E8 0F			       .BYTE    $0F         ; DTIMLO
   621 08E9 00			       .BYTE    $00         ; DRESVD
   622 08EA FF			       .BYTE    $FF         ; DBYTL
   623 08EB 00			       .BYTE    $00         ; DBYTH
   624 08EC FF			       .BYTE    $FF         ; DAUX1
   625 08ED 00			       .BYTE    $00         ; DAUX2
   626
   627 				; End CIO PUT
   628 				;---------------------------------------
   629
   630 				;---------------------------------------
   631 				; CIO STATUS 
   632 				;---------------------------------------
   633
   634 08EE 20 4A 0A		STATUS: JSR     ENPRCD      ; ENABLE PRCD
   635 08F1 20 5C 0A		        JSR     GDIDX       ; GET DEVICE#
   636 08F4 BD 56 17		        LDA     RLEN,X      ; GET RLEN
   637 08F7 D0 05		        BNE     STSLEN      ; RLEN > 0?
   638 08F9 AD 55 17		        LDA     TRIP
   639 08FC D0 15		        BNE     STTRI1      ; TRIP = 1?
   640
   641 				        ; NO TRIP, RETURN SAVED LEN
   642
   643 08FE BD 56 17		STSLEN: LDA     RLEN,X      ; GET RLEN
   644 0901 8D EA 02		        STA     DVSTAT      ; RET IN DVSTAT
   645
   646 				        ; If you don't need to preserve Y then use it instead of A
   647 0904 A9 00		        LDA     #$00
   648 0906 8D EB 02		        STA     DVSTAT+1
   649
   650 				        ; and INY here
   651 0909 A9 01		        LDA     #$01
   652 090B 8D EC 02		        STA     DVSTAT+2
   653 090E 8D ED 02		        STA     DVSTAT+3
   654
   655 0911 D0 0B		        BNE     STDONE
   656
   657 				        ; DO POLL AND UPDATE RCV LEN
   658
   659 0913 20 24 09		STTRI1: JSR     STPOLL      ; POLL FOR ST
   660 0916 9D 56 17		        STA     RLEN,X
   661
   662 				        ; UPDATE TRIP FLAG
   663
   664 0919 D0 03		STTRIU: BNE     STDONE
   665 091B 8D 55 17		        STA     TRIP        ; RLEN = 0
   666
   667 				        ; RETURN CONNECTED? FLAG.
   668
   669 091E AD EC 02		STDONE: LDA     DVSTAT+2
   670 0921 A0 01		        LDY     #$01
   671 0923 60			        RTS
   672
   673 				       ; ASK FUJINET FOR STATUS
   674
   675 0924			STPOLL:
   676 0924 A5 21		        LDA     ZICDNO      ; IOCB #
   677 0926 8D 49 09		        STA     STADCB+1
   678
   679 0929 A9 48		        LDA     #<STADCB
   680 092B A0 09		        LDY     #>STADCB
   681
   682 092D 20 A5 07		        JSR     DOSIOV
   683
   684 				        ;; > 127 bytes? make it 127 bytes.
   685
   686 0930 AD EB 02		        LDA     DVSTAT+1
   687 0933 D0 07		        BNE     STADJ
   688 0935 AD EA 02		        LDA     DVSTAT
   689 0938 30 02		        BMI     STADJ
   690 093A 50 08		        BVC     STP2        ; <= 127 bytes...
   691
   692 093C A9 7F		STADJ   LDA     #$7F
   693 093E 8D EA 02		        STA     DVSTAT
   694 				        
   695 0941 8D EB 02		        STA     DVSTAT+1
   696
   697 				       ; A = CONNECTION STATUS
   698
   699 0944 AD EC 02		STP2:   LDA     DVSTAT+2
   700 0947 60			        RTS
   701
   702 0948 71			STADCB: .BYTE   DEVIDN      ; DDEVIC
   703 0949 FF			        .BYTE   $FF         ; DUNIT
   704 094A 53			        .BYTE   'S'         ; DCOMND
   705 094B 40			        .BYTE   $40         ; DSTATS
   706 094C EA			        .BYTE   <DVSTAT     ; DBUFL
   707 094D 02			        .BYTE   >DVSTAT     ; DBUFH
   708 094E 0F			        .BYTE   $0F         ; DTIMLO
   709 094F 00			        .BYTE   $00         ; DRESVD
   710 0950 04			        .BYTE   $04         ; DBYTL
   711 0951 00			        .BYTE   $00         ; DBYTH
   712 0952 00			        .BYTE   $00         ; DAUX1
   713 0953 00			        .BYTE   $00         ; DAUX2
   714
   715 				; End CIO STATUS
   716 				;---------------------------------------
   717
   718 				;---------------------------------------
   719 				; CIO SPECIAL
   720 				;---------------------------------------
   721
   722 0954			SPEC:   ; HANDLE LOCAL COMMANDS.
   723
   724 0954 A5 22		        LDA     ZICCOM
   725 0956 C9 0F		        CMP     #$0F        ; 15 = FLUSH
   726 0958 D0 06		        BNE     S1          ; NO.
   727 095A 20 AF 08		        JSR     PFLUSH      ; DO FLUSH
   728 095D A0 01		        LDY     #$01        ; SUCCESS
   729 095F 60			        RTS
   730
   731 0960 C9 28		S1:     CMP     #40         ; 40 = LOAD AND EXECUTE
   732 0962 F0 03		        BEQ     S2          ; YES.
   733 0964 4C 68 09		        JMP     S3          ; NO. SKIP OVER spec40
   734
   735 0967 60			S2:     RTS
   736 				       ; HANDLE SIO COMMANDS.
   737 				       ; GET DSTATS FOR COMMAND
   738 0968			S3:
   739 0968 A5 21		        LDA     ZICDNO
   740 096A 8D B0 09		        STA     SPEDCB+1
   741 096D A5 22		        LDA     ZICCOM
   742 096F 8D B9 09		        STA     SPEDCB+10
   743
   744 0972 A9 AF		        LDA     #<SPEDCB
   745 0974 A0 09		        LDY     #>SPEDCB
   746 0976 20 A5 07		        JSR     DOSIOV
   747
   748 0979 30 0A		        BMI     :DSERR
   749
   750 				       ; WE GOT A DSTATS INQUIRY
   751 				       ; IF $FF, THE COMMAND IS
   752 				       ; INVALID
   753
   754 097B AD 62 17		DSOK:   LDA     INQDS
   755 097E C9 FF		        CMP     #$FF        ; INVALID?
   756 0980 D0 04		        BNE     DSGO        ; DO THE CMD
   757 0982 A0 92		        LDY     #$92        ; UNIMP CMD
   758 0984 98			        TYA
   759 0985			DSERR:
   760 0985 60			        RTS
   761
   762 				        ;; Do the special, since we want to pass in all the IOCB
   763 				        ;; Parameters to the DCB, This is being done long-hand.
   764
   765 0986 A5 22		DSGO:   LDA     ZICCOM
   766 0988 48			        PHA
   767 0989 A9 00		        LDA     #$00
   768 098B 48			        PHA
   769 098C AD 62 17		        LDA     INQDS
   770 098F 48			        PHA
   771 0990 A9 01		        LDA     #$01
   772 0992 48			        PHA
   773 0993 A5 24		        LDA     ZICBAL
   774 0995 48			        PHA
   775 0996 A5 2A		        LDA     ZICAX1
   776 0998 48			        PHA
   777 0999 A5 25		        LDA     ZICBAH
   778 099B 48			        PHA
   779 099C A5 2B		        LDA     ZICAX2
   780 099E 48			        PHA
   781 099F A0 03		        LDY     #$03
   782 09A1			DSGOL:
   783 09A1 68			        PLA
   784 09A2 99 08 03		        STA     DBYTL,Y
   785 09A5 68			        PLA
   786 09A6 99 02 03		        STA     DCOMND,Y
   787 09A9 88			        DEY
   788 09AA 10 F5		        BPL     DSGOL
   789
   790 09AC 4C B6 07		        JMP     SIOVDST
   791
   792 				        ;; Return DSTATS in Y and A
   793
   794 09AF 71			SPEDCB  .BYTE   DEVIDN      ; DDEVIC
   795 09B0 FF			        .BYTE   $FF         ; DUNIT
   796 09B1 FF			        .BYTE   $FF         ; DCOMND ; inq
   797 09B2 40			        .BYTE   $40         ; DSTATS
   798 09B3 62			        .BYTE   <INQDS      ; DBUFL
   799 09B4 17			        .BYTE   >INQDS      ; DBUFH
   800 09B5 0F			        .BYTE   $0F         ; DTIMLO
   801 09B6 00			        .BYTE   $00         ; DRESVD
   802 09B7 01			        .BYTE   $01         ; DBYTL
   803 09B8 00			        .BYTE   $00         ; DBYTH
   804 09B9 FF			        .BYTE   $FF         ; DAUX1
   805 09BA FF			        .BYTE   $FF         ; DAUX2
   806
   807 				; End CIO SPECIAL
   808 				;---------------------------------------
   809
   810 				;#######################################
   811 				;#                                     #
   812 				;#             CIO Functions           # 
   813 				;#                                     #
   814 				;#######################################
   815
   816
   817 				;---------------------------------------
   818 09BB			CIOCLOSE:
   819 				;---------------------------------------
   820 				    ; X must contain IOCB offset ($10,$20,..)
   821 09BB A9 0C		        LDA     #$0C            ; Close #1 first
   822 09BD 9D 42 03		        STA     ICCOM,X
   823 09C0 4C 56 E4		        JMP     CIOV
   824
   825 				;---------------------------------------
   826 09C3			CIOOPEN:
   827 				;---------------------------------------
   828 				    ; Input: 
   829 				    ; X = IOCB offset ($10,$20,..)
   830 				    ; Y = data direction (4=inp,8=out,12=i/o)
   831 				    ; INBUFF contains ICBAL/H
   832 09C3 A9 03		        LDA     #$03            ; 3 = CIO 'OPEN FILE'
   833 09C5 9D 42 03		        STA     ICCOM,X
   834 09C8 A5 F3		        LDA     INBUFF          ; Pointer to filename
   835 09CA 9D 44 03		        STA     ICBAL,X
   836 09CD A5 F4		        LDA     INBUFF+1        ; Pointer to filename
   837 09CF 9D 45 03		        STA     ICBAH,X
   838 09D2 98			        TYA
   839 09D3 9D 4A 03		        STA     ICAX1,X         ; Data direction
   840 09D6 A9 00		        LDA     #$00
   841 09D8 9D 4B 03		        STA     ICAX2,X         ; Unused
   842 09DB 20 56 E4		        JSR     CIOV            ; Call CIO
   843 09DE 20 A4 0A		        JSR     PRINT_ERROR
   844
   845 09E1			CIOOPEN_DONE:
   846 09E1 60			        RTS
   847
   848 				;---------------------------------------
   849 09E2			CIOSTATUS:
   850 				;---------------------------------------
   851 09E2 A9 0D		        LDA     #$0D
   852 09E4 9D 42 03		        STA     ICCOM,X
   853 09E7 20 56 E4		        JSR     CIOV
   854 09EA 10 03		        BPL     CIOSTATUS_DONE
   855 09EC 20 A4 0A		        JSR     PRINT_ERROR
   856
   857 09EF			CIOSTATUS_DONE:
   858 09EF 60			        RTS
   859 				        
   860
   861 				;---------------------------------------
   862 09F0			CIOGET:
   863 				;---------------------------------------
   864 				    ; Input: 
   865 				    ; X = IOCB offset ($10,$20,..)
   866 				    ; A = ICBLL
   867 				    ; Y = ICBLH
   868 				    ; INBUFF contains ICBAL/H
   869 09F0 48			        PHA                 ; Stash Buffer length Lo
   870 09F1 A9 07		        LDA     #$07        ; GET BYTES command
   871 09F3 9D 42 03		        STA     ICCOM,X
   872 09F6 A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   873 09F8 9D 44 03		        STA     ICBAL,X
   874 09FB A5 F4		        LDA     INBUFF+1
   875 09FD 9D 45 03		        STA     ICBAH,X
   876 0A00 68			        PLA                 ; Retrieve Buffer length Lo
   877 0A01 9D 48 03		        STA     ICBLL,X
   878 0A04 98			        TYA                 ; Get Buffer length Hi
   879 0A05 9D 49 03		        STA     ICBLH,X
   880 0A08 20 56 E4		        JSR     CIOV        ; Bon voyage
   881 0A0B 10 00		        BPL     CIOGET_DONE
   882 				;        JMP     PRINT_ERROR
   883
   884 0A0D			CIOGET_DONE:
   885 0A0D 60			        RTS
   886
   887 				;---------------------------------------
   888 0A0E			CIOPUT:
   889 				;---------------------------------------
   890 				    ; Input: 
   891 				    ; X = IOCB offset ($10,$20,..)
   892 				    ; A = ICBLL
   893 				    ; Y = ICBLH
   894 				    ; INBUFF contains ICBAL/H
   895 0A0E 48			        PHA                 ; Stash Buffer length Lo
   896 0A0F A9 0B		        LDA     #$0B        ; PUT BYTES command
   897 0A11 9D 42 03		        STA     ICCOM,X
   898 0A14 A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   899 0A16 9D 44 03		        STA     ICBAL,X
   900 0A19 A5 F4		        LDA     INBUFF+1
   901 0A1B 9D 45 03		        STA     ICBAH,X
   902 0A1E 68			        PLA                 ; Retrieve Buffer length Lo
   903 0A1F 9D 48 03		        STA     ICBLL,X
   904 0A22 98			        TYA                 ; Get Buffer length Hi
   905 0A23 9D 49 03		        STA     ICBLH,X
   906 0A26 20 56 E4		        JSR     CIOV        ; Bon voyage
   907 0A29 10 00		        BPL     CIOPUT_DONE
   908 				;        JMP     PRINT_ERROR
   909
   910 0A2B			CIOPUT_DONE:
   911 0A2B 60			        RTS
   912
   913 				;---------------------------------------
   914 0A2C			CIOGETREC:
   915 				;---------------------------------------
   916 				    ; Input: 
   917 				    ; X = IOCB offset ($10,$20,..)
   918 				    ; A = ICBLL
   919 				    ; Y = ICBLH
   920 				    ; INBUFF contains ICBAL/H
   921 0A2C 48			        PHA                 ; Stash Buffer length Lo
   922 0A2D A9 05		        LDA     #$05        ; GET RECORD command
   923 0A2F 9D 42 03		        STA     ICCOM,X
   924 0A32 A5 F3		        LDA     INBUFF      ; Get buffer addr from pointer
   925 0A34 9D 44 03		        STA     ICBAL,X
   926 0A37 A5 F4		        LDA     INBUFF+1
   927 0A39 9D 45 03		        STA     ICBAH,X
   928 0A3C 68			        PLA                 ; Retrieve Buffer length Lo
   929 0A3D 9D 48 03		        STA     ICBLL,X
   930 0A40 98			        TYA                 ; Get Buffer length Hi
   931 0A41 9D 49 03		        STA     ICBLH,X
   932
   933 0A44 20 56 E4		        JSR     CIOV        ; Bon voyage
   934 0A47 10 00		        BPL     CIOGETREC_DONE
   935 				;        JMP     PRINT_ERROR
   936
   937 0A49			CIOGETREC_DONE:
   938 0A49 60			        RTS
   939
   940 				;#######################################
   941 				;#                                     #
   942 				;#          Utility Functions          #
   943 				;#                                     #
   944 				;#######################################
   945 				    ; ENABLE PROCEED INTERRUPT
   946
   947 0A4A AD 02 D3		ENPRCD: LDA     PACTL
   948 0A4D 09 01		        ORA     #$01        ; ENABLE BIT 0
   949 0A4F 8D 02 D3		        STA     PACTL
   950 0A52 60			        RTS
   951
   952 				   ; DISABLE PROCEED INTERRUPT
   953
   954 0A53 AD 02 D3		DIPRCD: LDA     PACTL
   955 0A56 29 FE		        AND     #$FE        ; DISABLE BIT0
   956 0A58 8D 02 D3		        STA     PACTL
   957 0A5B 60			        RTS
   958
   959 				   ; GET ZIOCB DEVNO - 1 INTO X
   960
   961 0A5C A6 21		GDIDX:  LDX     ZICDNO      ; IOCB UNIT #
   962 0A5E CA			        DEX                 ; - 1
   963 0A5F 60			        RTS
   964
   965 				    ; Convert char in A from upper-case to lower-case
   966 0A60			TOUPPER:
   967 0A60 C9 61		        CMP     #'a'        ; SKip if < 'a'
   968 0A62 90 06		        BCC     @+
   969 0A64 C9 7B		        CMP     #'z'+1      ; Skip if > 'z'
   970 0A66 B0 02		        BCS     @+
   971 0A68 29 5F		        AND     #$5F        ; Disable high-bit and convert to lower
   972 0A6A 60			 @:     RTS
   973
   974 				;---------------------------------------
   975 				; Proceed Vector
   976 				;---------------------------------------
   977
   978 0A6B A9 01		PRCVEC: LDA     #$01
   979 0A6D 8D 55 17		        STA     TRIP
   980 0A70 68			        PLA
   981 0A71 40			        RTI
   982
   983 				; End Proceed Vector
   984 				;---------------------------------------
   985
   986 				;---------------------------------------
   987 				; Reset LNBUF
   988 				;---------------------------------------
   989 				; Normally this routine is at $DA51
   990 				; But some programs will bank-switch
   991 				; that portion of ROM to RAM
   992 				;---------------------------------------
   993
   994 0A72 A9 05		LDBUFA: LDA     #$05
   995 0A74 85 F4		        STA     INBUFF+1
   996 0A76 A9 82		        LDA     #$82        ; Normally $80. 2 for headroom
   997 0A78 85 F3		        STA     INBUFF
   998 0A7A 60			        RTS
   999
  1000 				; End Reset LNBUF
  1001 				;---------------------------------------
  1002
  1003 				;---------------------------------------
  1004 				; Skip spaces
  1005 				;---------------------------------------
  1006 				; Normally this routine is at $DBA1
  1007 				; But some programs will bank-switch
  1008 				; that portion of ROM to RAM
  1009 				;---------------------------------------
  1010
  1011 0A7B A4 F2		SKPSPC: LDY     CIX
  1012 0A7D A9 20		        LDA     #$20
  1013 0A7F D1 F3		@:      CMP     (INBUFF),Y
  1014 0A81 D0 03		        BNE     @+
  1015 0A83 C8			        INY
  1016 0A84 D0 F9		        BNE     @-
  1017 0A86 84 F2		@:      STY     CIX
  1018 0A88 60			        RTS
  1019
  1020 				; End SKPSPC
  1021 				;---------------------------------------
  1022
  1023 				;---------------------------------------
  1024 				; Print EOL-terminated string
  1025 				; A: String Buffer Lo
  1026 				; Y: String Buffer Hi
  1027 				;---------------------------------------
  1028 0A89			PRINT_STRING:
  1029
  1030 0A89 A2 00		        LDX     #$00
  1031 				    ;---------------------------------------
  1032 				    ; String Buffer
  1033 				    ;---------------------------------------
  1034 0A8B 9D 44 03		        STA     ICBAL,X
  1035 0A8E 98			        TYA
  1036 0A8F 9D 45 03		        STA     ICBAH,X
  1037
  1038 				    ;---------------------------------------
  1039 				    ; String Length
  1040 				    ;---------------------------------------
  1041 0A92 A9 80		        LDA     #$80
  1042 0A94 9D 48 03		        STA     ICBLL,X
  1043 0A97 A9 00		        LDA     #$00
  1044 0A99 9D 49 03		        STA     ICBLH,X
  1045
  1046 				    ;---------------------------------------
  1047 				    ; Call to CIO
  1048 				    ;---------------------------------------
  1049 0A9C A9 09		        LDA     #PUTREC
  1050 0A9E 9D 42 03		        STA     ICCOM,X
  1051 0AA1 4C 56 E4		        JMP     CIOV
  1052
  1053 				;---------------------------------------
  1054 				; Print integer error number from DOSIOV
  1055 				; Y: Return code from DOSIOV
  1056 				;---------------------------------------
  1057 0AA4			PRINT_ERROR:
  1058 0AA4 C0 01		        CPY     #$01        ; Exit if success (1)
  1059 0AA6 F0 33		        BEQ     PRINT_ERROR_DONE
  1060
  1061 				    ;-----------------------------------
  1062 				    ; If error code = 144, then get
  1063 				    ; extended code from DVSTAT
  1064 				    ;-----------------------------------
  1065 0AA8 C0 90		        CPY     #144
  1066 0AAA D0 0A		        BNE     PRINT_ERROR_NEXT
  1067
  1068 0AAC A9 48		        LDA     #<STADCB
  1069 0AAE A0 09		        LDY     #>STADCB
  1070 0AB0 20 A5 07		        JSR     DOSIOV
  1071 0AB3 AC ED 02		        LDY     DVSTAT+3    ;
  1072
  1073 0AB6			PRINT_ERROR_NEXT:
  1074 				    ;-----------------------------------
  1075 				    ; Convert error code to ASCII
  1076 				    ;-----------------------------------
  1077 0AB6 84 D4		        STY     FR0
  1078 0AB8 A9 00		        LDA     #$00
  1079 0ABA 85 D5		        STA     FR0+1
  1080 0ABC 20 AA D9		        JSR     IFP         ; Convert error from int to floating point
  1081 0ABF 20 E6 D8		        JSR     FASC        ; Convert floating point to ASCII
  1082
  1083 				    ;---------------------------------------
  1084 				    ; Find last char in ASCII error (noted by high bit)
  1085 				    ; Unset high bit & append EOL
  1086 				    ;---------------------------------------
  1087 0AC2 A0 FF		        LDY     #$FF        ; Init counter = 0
  1088
  1089 0AC4 C8			@       INY
  1090 0AC5 B1 F3		        LDA     (INBUFF),Y
  1091 0AC7 C9 80		        CMP     #$80
  1092 0AC9 90 F9		        BCC     @-
  1093
  1094 0ACB 29 7F		        AND     #$7F        ; Clear high bit
  1095 0ACD 91 F3		        STA     (INBUFF),Y
  1096 0ACF C8			        INY
  1097 0AD0 A9 9B		        LDA     #EOL        ; Append EOL
  1098 0AD2 91 F3		        STA     (INBUFF),Y
  1099
  1100 0AD4 A5 F3		        LDA     INBUFF
  1101 0AD6 A4 F4		        LDY     INBUFF+1
  1102 0AD8 4C 89 0A		        JMP     PRINT_STRING
  1103
  1104 0ADB			PRINT_ERROR_DONE:
  1105 0ADB 60			        RTS
  1106
  1107 				; End PRINTSCR
  1108 				;---------------------------------------
  1109
  1110
  1111 				;#######################################
  1112 				;#                                     #
  1113 				;#       COMMAND PROCESSOR (CP)        #
  1114 				;#                                     #
  1115 				;#######################################
  1116
  1117 				;---------------------------------------
  1118 				; DOS Entry point (DOSVEC points here)
  1119 				;---------------------------------------
  1120 0ADC			DOS:
  1121 				        ; Bypass Autorun if OPTION switch held
  1122 0ADC AD 1F D0		        LDA     CONSOL
  1123 0ADF C9 03		        CMP     #OPTION
  1124 0AE1 F0 0D		        BEQ     CPLOOP
  1125 				        ; Autorun injection
  1126 0AE3 A9 0E		        LDA     #CMD_IDX.AUTORUN    ; Check for AUTORUN
  1127 0AE5 CD 54 17		        CMP     AUTORUN_FLG         ; True only on 1st entry (TODO Is this working?)
  1128 0AE8 F0 06		        BEQ     CPLOOP              ; Skip to Command Processor
  1129 0AEA 8D 54 17		        STA     AUTORUN_FLG         ; Change flag
  1130 0AED 20 EF 11		        JSR     SUBMIT_AUTORUN      ; Attempt to execute autorun file
  1131 				       
  1132 0AF0			CPLOOP:
  1133 0AF0 20 F6 0A		        JSR     CP          ; Command Processor
  1134 0AF3 4C F0 0A		        JMP     CPLOOP      ; Keep looping
  1135
  1136 				;---------------------------------------
  1137 				; Main loop
  1138 				;---------------------------------------
  1139 0AF6			CP:
  1140 0AF6 A9 FF		        LDA     #$FF        ; Clear command
  1141 0AF8 8D 51 17		        STA     CMD
  1142
  1143 0AFB 20 0A 0B		        JSR     SHOWPROMPT
  1144 0AFE 20 2F 0B		        JSR     GETCMD
  1145 0B01			AUTORUN_DO:
  1146 0B01 20 9E 0B		        JSR     PARSECMD
  1147 0B04 30 03		        BMI     CP_DONE     ; Skip DOCMD if CMD == $FF
  1148 0B06 20 51 0C		        JSR     DOCMD
  1149 0B09			CP_DONE:
  1150 0B09 60			        RTS
  1151
  1152 				;---------------------------------------
  1153 				; Show Command Prompt (Nn:)
  1154 				; Leading EOF requires special CIOV call
  1155 				;---------------------------------------
  1156
  1157 				;---------------------------------------
  1158 0B0A			SHOWPROMPT:
  1159 				;---------------------------------------
  1160
  1161 0B0A AD 50 17		        LDA     DOSDR       ; Get the 1,2,... for N1,N2,...
  1162 0B0D 09 30		        ORA     #'0'        ; Convert, say, 1 to '1'
  1163 0B0F 8D EE 15		        STA     PRMPT+2     ; Store in after EOL and N
  1164
  1165 0B12 A2 00		        LDX     #$00
  1166 0B14 A9 0B		        LDA     #PUTCHR
  1167 0B16 9D 42 03		        STA     ICCOM,X
  1168
  1169 0B19 A9 EC		        LDA     #<PRMPT
  1170 0B1B 9D 44 03		        STA     ICBAL,X
  1171 0B1E A9 15		        LDA     #>PRMPT
  1172
  1173 0B20 9D 45 03		        STA     ICBAH,X
  1174 0B23 A9 04		        LDA     #4          ; Prompt length = 4
  1175 0B25 9D 48 03		        STA     ICBLL,X
  1176 0B28 8A			        TXA                 ; Still zero
  1177 0B29 9D 49 03		        STA     ICBLH,X
  1178
  1179 0B2C 4C 56 E4		        JMP     CIOV
  1180
  1181 				;---------------------------------------
  1182 0B2F			GETCMD:
  1183 				;---------------------------------------
  1184 0B2F A2 00		        LDX     #$00
  1185 0B31 A9 05		        LDA     #GETREC
  1186 0B33 9D 42 03		        STA     ICCOM,X
  1187 0B36 A9 82		        LDA     #<LNBUF
  1188 0B38 9D 44 03		        STA     ICBAL,X
  1189 0B3B A9 05		        LDA     #>LNBUF
  1190 0B3D 9D 45 03		        STA     ICBAH,X
  1191 0B40 A9 7F		        LDA     #$7F
  1192 0B42 9D 48 03		        STA     ICBLL,X
  1193 0B45 20 56 E4		        JSR     CIOV
  1194
  1195 0B48			GETCMDTEST:
  1196 0B48 A0 00		        LDY     #$00
  1197 0B4A 84 F2		        STY     CIX
  1198 0B4C 20 72 0A		        JSR     LDBUFA      ; Reset LNBUF to $0580
  1199 0B4F 20 7B 0A		        JSR     SKPSPC      ; Advance CIX to next space
  1200
  1201 				    ;---------------------------------------
  1202 				    ; CMDSEP is an sequence of bytes contains
  1203 				    ; indexes to chars following spaces
  1204 				    ; Iterate to clear CMDSEP bytes
  1205 				    ;---------------------------------------
  1206 0B52 98			        TYA                 ; A = 0
  1207 0B53 A2 02		        LDX     #$02        ; for X = 2 to 0 step -1
  1208 0B55			GETLOOP:
  1209 0B55 9D 9A 0B		        STA     CMDSEP,X
  1210 0B58 CA			        DEX
  1211 0B59 10 FA		        BPL     GETLOOP     ; next X
  1212
  1213 				    ; Initial Delimiter to space
  1214 0B5B A9 20		        LDA     #' '
  1215 0B5D 8D 9D 0B		        STA     DELIM
  1216
  1217 				    ;---------------------------------------
  1218 				    ; Loop until EOL is encountered
  1219 				    ;---------------------------------------
  1220 0B60 E8			        INX                 ; Reset X to 0
  1221 0B61			GETCMD_LOOP:
  1222 0B61 B1 F3		        LDA     (INBUFF),Y
  1223 0B63 C9 9B		        CMP     #EOL        ; Found EOL?
  1224 0B65 F0 32		        BEQ     GETCMD_DONE ; yes. skip
  1225 0B67 CD 9D 0B		        CMP     DELIM       ; Found space?
  1226 0B6A F0 03		        BEQ     GETCMD_REPL ; yes. Replace it
  1227 0B6C C8			        INY
  1228 0B6D D0 F2		        BNE     GETCMD_LOOP ; "always" non-zero
  1229
  1230 				    ;---------------------------------------
  1231 				    ; March through the cmd line and note
  1232 				    ; the positions of any args as delimited
  1233 				    ; by spaces or quotes. positions saved
  1234 				    ; in CMDSEP,X
  1235 				    ;---------------------------------------
  1236 0B6F			GETCMD_REPL:
  1237 0B6F A9 9B		        LDA     #EOL
  1238 0B71 91 F3		        STA     (INBUFF),Y
  1239 0B73 C8			        INY
  1240 0B74 B1 F3		        LDA     (INBUFF),Y  ; Skip any run of spaces
  1241 0B76 C9 20		        CMP     #' '
  1242 0B78 F0 F5		        BEQ     GETCMD_REPL ; Keep skipping spaces
  1243
  1244 				    ; Here if any run of spaces has ended
  1245 				    ; Are we standing on a double-quote?
  1246 0B7A C9 22		        CMP     #'"'
  1247 0B7C D0 12		        BNE     GETCMD_WR_OFFSET  ; No. Skip ahead
  1248
  1249 				    ; Here if curr char is a double-quote
  1250 0B7E C8			        INY                 ; Advance the command line index
  1251 0B7F A9 22		        LDA     #'"'        ; Is the curr delim a double-quote?
  1252 0B81 CD 9D 0B		        CMP     DELIM       ; If not, change delim to double-quote
  1253 0B84 D0 07		        BNE     GETCMD_DQ_DELIM
  1254
  1255 				    ; Here if curr delim is a double-quote
  1256 				    ; Switch delim to space
  1257 0B86 A9 20		        LDA     #' '
  1258 0B88 8D 9D 0B		        STA     DELIM
  1259 0B8B D0 03		        BNE     GETCMD_WR_OFFSET
  1260
  1261 				    ; Here if curr delim is space
  1262 				    ; Switch delim to double-quote
  1263 0B8D			GETCMD_DQ_DELIM:
  1264 0B8D 8D 9D 0B		        STA     DELIM
  1265
  1266 				    ; Note the position for the curr command-line arg
  1267 0B90			GETCMD_WR_OFFSET:
  1268 0B90 98			        TYA
  1269 0B91 9D 9A 0B		        STA     CMDSEP,X
  1270 0B94 E8			        INX
  1271 0B95 E0 03		        CPX     #$03
  1272 0B97 90 C8		        BCC     GETCMD_LOOP ; Continue searching
  1273
  1274 0B99			GETCMD_DONE:
  1275 0B99 60			        RTS
  1276
  1277 0B9A FF FF FF		CMDSEP: .BYTE $FF,$FF,$FF
  1278 0B9D 20			DELIM:  .BYTE ' '
  1279
  1280 				;---------------------------------------
  1281 0B9E			PARSECMD:
  1282 				;---------------------------------------
  1283 				        ;LDA     LNBUF
  1284 0B9E A0 00		        LDY     #$00
  1285 0BA0 B1 F3		        LDA     (INBUFF),Y
  1286 0BA2 C9 9B		        CMP     #EOL        ; Quit immediately if no cmd
  1287 0BA4 F0 0C		        BEQ     PARSECMD_DONE
  1288
  1289 0BA6 20 C7 0B		        JSR     PARSE_INTRINSIC_COMMAND
  1290 0BA9 20 01 0C		        JSR     PARSE_DRIVE_CHANGE
  1291 0BAC 20 18 0C		        JSR     PARSE_EXTRINSIC_COMMAND
  1292 0BAF 20 B3 0B		        JSR     PRINT_UNK_CMD
  1293 0BB2			PARSECMD_DONE:
  1294 0BB2 60			        RTS
  1295
  1296 0BB3			PRINT_UNK_CMD:
  1297 0BB3 AD 51 17		        LDA     CMD
  1298 0BB6 C9 FF		        CMP     #$FF
  1299 0BB8 D0 07		        BNE     PRINT_UNK_CMD_DONE
  1300 0BBA A9 C2		        LDA     #<UNK_CMD_ERR
  1301 0BBC A0 0B		        LDY     #>UNK_CMD_ERR
  1302 0BBE 20 89 0A		        JSR     PRINT_STRING
  1303 0BC1			PRINT_UNK_CMD_DONE:
  1304 0BC1 60			        RTS
  1305
  1306 0BC2			UNK_CMD_ERR:
  1307 0BC2 43 4D 44 3F 9B	        .BYTE   'CMD?',EOL
  1308
  1309 				;---------------------------------------
  1310 0BC7			PARSE_INTRINSIC_COMMAND:
  1311 				;---------------------------------------
  1312 0BC7 A2 00		        LDX     #$00        ; Initialize X for command code indexing
  1313 0BC9 A0 00		        LDY     #$00
  1314 0BCB 84 F2		        STY     CIX
  1315 0BCD 20 72 0A		        JSR     LDBUFA      ; Set INBUFF to $0580, er make that TBUF
  1316
  1317 0BD0 20 7B 0A		@:      JSR     SKPSPC      ; Skip whitespace
  1318
  1319 0BD3			PARSE_INTRINSIC_NEXT_CHAR:
  1320 0BD3 B1 F3		        LDA     (INBUFF),Y
  1321 0BD5 29 5F		        AND     #$5F        ; Disable high-bit and convert to upper
  1322 0BD7 5D 0D 16		        EOR     COMMAND,X   ; X initialized to 0 in caller
  1323 0BDA C8			        INY
  1324 0BDB 0A			        ASL
  1325 0BDC F0 0B		        BEQ     PARSE_INTRINSIC_CHAR_OK
  1326
  1327 				        ; Skip to next command
  1328
  1329 0BDE			PARSE_INTRINSIC_NEXT_COMMAND:
  1330 0BDE BD 0D 16		        LDA     COMMAND,X
  1331 0BE1 0A			        ASL
  1332 0BE2 E8			        INX
  1333 0BE3 90 F9		        BCC     PARSE_INTRINSIC_NEXT_COMMAND
  1334 0BE5 A4 F2		        LDY     CIX
  1335 0BE7 E0 C8		        CPX     #COMMAND_SIZE
  1336
  1337 0BE9			PARSE_INTRINSIC_CHAR_OK:
  1338 0BE9 E8			        INX
  1339 0BEA 90 E7		        BCC     PARSE_INTRINSIC_NEXT_CHAR
  1340 0BEC 84 F2		        STY     CIX
  1341 0BEE B1 F3		        LDA     (INBUFF),Y
  1342 0BF0 30 05		        BMI     PARSE_INTRINSIC_RET
  1343
  1344 0BF2 20 7B 0A		        JSR     SKPSPC
  1345
  1346 0BF5			PARSE_INTRINSIC_RET_ERROR:
  1347 0BF5 A2 C9		        LDX     #COMMAND_SIZE+1
  1348 0BF7			PARSE_INTRINSIC_RET:
  1349 0BF7 BD 0D 16		        LDA     COMMAND,X
  1350 0BFA 8D 51 17		        STA     CMD
  1351 0BFD 8D 52 17		        STA     CMDPRV
  1352 0C00			PARSE_INTRINSIC_DONE:
  1353 0C00 60			        RTS
  1354
  1355 				; End of PARSE_INTRINSIC_COMMAND
  1356 				;---------------------------------------
  1357
  1358 				;---------------------------------------
  1359 0C01			PARSE_DRIVE_CHANGE:
  1360 				;---------------------------------------
  1361 0C01 A2 03		        LDX     #$03        ; Check for EOL in pos 3
  1362 0C03 BD 82 05		        LDA     LNBUF,X
  1363 0C06 C9 9B		        CMP     #EOL
  1364 0C08 D0 0D		        BNE     PARSE_DRIVE_CHANGE_DONE
  1365 0C0A CA			        DEX                 ; go back one char
  1366 0C0B BD 82 05		        LDA     LNBUF,X
  1367 0C0E C9 3A		        CMP     #':'        ; Check for colon.
  1368 0C10 D0 05		        BNE     PARSE_DRIVE_CHANGE_DONE
  1369 0C12 A9 1C		        LDA     #CMD_IDX.DRIVE_CHG
  1370 0C14 8D 51 17		        STA     CMD
  1371 0C17			PARSE_DRIVE_CHANGE_DONE:
  1372 0C17 60			        RTS
  1373
  1374 				;---------------------------------------
  1375 0C18			PARSE_EXTRINSIC_COMMAND:
  1376 				;---------------------------------------
  1377 				    ; Quit if CMD has been found earlier
  1378 0C18 AE 51 17		        LDX     CMD         ; Undefined CMD = $FF
  1379 0C1B E8			        INX                 ; now 0 if undefined
  1380 0C1C D0 F9		        BNE     PARSE_DRIVE_CHANGE_DONE ; Exit if defined CMD
  1381
  1382 				    ; Here if  CMD is undefined.
  1383 				    ; From here we'll assume it's a filename for a executable
  1384 				    ; and attempt to LOAD it. But first append a ".COM"
  1385 				    ; and shift the filename to the right
  1386
  1387 				    ; Find offset to EOL
  1388 0C1E A0 FF		        LDY     #$FF
  1389 0C20 C8			@       INY
  1390 0C21 B1 F3		        LDA     (INBUFF),Y
  1391 0C23 C9 9B		        CMP     #EOL
  1392 0C25 D0 F9		        BNE     @-
  1393
  1394 				    ; Y contains offset to last char & stash it
  1395 0C27 98			        TYA
  1396 0C28 48			        PHA
  1397
  1398 				    ; Advance Y to allow the 5 chars of '.COM',EOL
  1399 0C29 18			        CLC
  1400 0C2A 69 05		        ADC     #$05
  1401 0C2C A8			        TAY
  1402
  1403 				    ; Append .COM, EOL
  1404 0C2D A2 04		        LDX     #$04
  1405 0C2F BD 4C 0C		@:      LDA     CMDEXT,X
  1406 0C32 91 F3		        STA     (INBUFF),Y
  1407 0C34 88			        DEY
  1408 0C35 CA			        DEX                     ; 
  1409 0C36 10 F7		        BPL     @-
  1410
  1411 				    ; Shift executable name to the right to allow room for PREPEND_DRIVE
  1412 				    ; Stack contains offset to last char
  1413 				    ; Y is still counting down from where '.COM' was appended.
  1414 0C38 68			        PLA                 ; Get offset to last char of executable
  1415 0C39 AA			        TAX                 ; It'll be used for indexing
  1416 0C3A CA			        DEX                 ; Skip original EOF
  1417 0C3B			SHIFT_LOOP:
  1418 0C3B BD 82 05		        LDA     LNBUF,X     ; Get source ch
  1419 0C3E 91 F3		@:      STA     (INBUFF),Y  ; Copy ch to new location
  1420 0C40 88			        DEY                 ; Point to next dest ch
  1421 0C41 CA			        DEX                 ; Point to next source ch
  1422 0C42 10 F7		        BPL     SHIFT_LOOP  ; Until X = 0
  1423
  1424 				    ; Let DO_LOAD attempt to execute the file
  1425 0C44 A9 01		        LDA     #$01        ; Point to start of filename
  1426 0C46 8D 9A 0B		        STA     CMDSEP      ; so DO_LOAD will treat it like
  1427 0C49 4C FF 0D		        JMP     DO_LOAD     ; 'LOAD filename'
  1428
  1429 0C4C			CMDEXT:
  1430 0C4C 2E 43 4F 4D 9B	        .BYTE   '.COM',EOL
  1431
  1432 				; End of PARSE_EXTRINSIC_COMMAND
  1433 				;---------------------------------------
  1434
  1435 				;---------------------------------------
  1436 0C51			DOCMD:
  1437 				;---------------------------------------
  1438 0C51 AE 51 17		        LDX     CMD
  1439 0C54 30 08		        BMI     DOCMD_DONE  ; Unassigned command = $FF
  1440 0C56 BD F4 16		        LDA     CMD_TAB_H,X ; Get hi-byte of subroutine's addr
  1441 0C59 48			        PHA                 ; Push it to the stack
  1442 0C5A BD D7 16		        LDA     CMD_TAB_L,X ; Get lo-byte of subroutine's addr
  1443 0C5D 48			        PHA                 ; Push it to the stack
  1444 0C5E			DOCMD_DONE:
  1445 0C5E 60			        RTS                 ; Use stack & RTS to jump to subroutine
  1446
  1447 				; End of DOCMD
  1448 				;---------------------------------------
  1449
  1450 				;---------------------------------------
  1451 0C5F			DO_DRIVE_CHG:
  1452 				;---------------------------------------
  1453 0C5F AD 82 05		        LDA     LNBUF
  1454 0C62 8D ED 15		        STA     PRMPT+1
  1455 0C65 AD 83 05		        LDA     LNBUF+1
  1456 0C68 C9 31		        CMP     #'1'        ; Skip if < '1'
  1457 0C6A 90 0A		        BCC     DO_DRIVE_CHG_ERROR
  1458 0C6C C9 39		        CMP     #'9'        ; Skip if >= '9'
  1459 0C6E B0 06		        BCS     DO_DRIVE_CHG_ERROR
  1460 0C70 29 0F		        AND     #$0F        ; Convert, say, to 1-8
  1461 0C72 8D 50 17		        STA     DOSDR
  1462 0C75 60			        RTS
  1463 0C76			DO_DRIVE_CHG_ERROR:
  1464 0C76 A9 46		        LDA     #<CDERR
  1465 0C78 A0 17		        LDY     #>CDERR
  1466 0C7A 4C 89 0A		        JMP     PRINT_STRING
  1467
  1468 				; End of DOCMD
  1469
  1470 				;---------------------------------------
  1471 				; Returns DOSDR in X
  1472 				; If arg1 contains Nn: then reg X = n
  1473 				; Otherwise X = DOSDR (from curr prompt)
  1474 				;---------------------------------------
  1475 0C7D			GET_DOSDR:
  1476 				;---------------------------------------
  1477
  1478 0C7D 20 72 0A		        JSR     LDBUFA      ; Reset INBUFF to LNBUF
  1479 0C80 AE 50 17		        LDX     DOSDR       ; Set DUNIT(X) to curr drive
  1480
  1481 				    ;---------------------------------------
  1482 				    ; Consider arg1 = N2:TNFS://localhost/
  1483 				    ; Check arg1 for ":" in 3rd position
  1484 				    ; if found then use char in 2nd position ('2') as DOSDR
  1485 				    ; First, change INBUFF to point to beg. of 1st arg
  1486 				    ;---------------------------------------
  1487 0C83 AD 9A 0B		        LDA     CMDSEP              ; arg offset
  1488 0C86 F0 17		        BEQ     GET_DOSDR_DONE      ; first, if arg1 not pop, leave X as-is & quit
  1489
  1490 0C88 18			        CLC                         ; Advance pointer to LNBUF
  1491 0C89 65 F3		        ADC     INBUFF
  1492 0C8B 85 F3		        STA     INBUFF
  1493 0C8D 90 02		        BCC     GET_DOSDR_NEXT
  1494 0C8F E6 F4		        INC     INBUFF+1
  1495
  1496 0C91			GET_DOSDR_NEXT:
  1497 0C91 A0 02		        LDY     #$02            ; Check for ':' in 3rd pos
  1498 0C93 B1 F3		        LDA     (INBUFF),Y
  1499 0C95 C9 3A		        CMP     #':'
  1500 0C97 D0 06		        BNE     GET_DOSDR_DONE  ; Not found, skip & use default
  1501 0C99 88			        DEY
  1502 0C9A B1 F3		        LDA     (INBUFF),Y
  1503 0C9C 29 0F		        AND     #$0F            ; Convert, say, '2' to 2
  1504 0C9E AA			        TAX                     ; Return DOSDR in X
  1505
  1506 0C9F			GET_DOSDR_DONE:
  1507 0C9F 60			        RTS
  1508
  1509 				;---------------------------------------
  1510 0CA0			DO_GENERIC:
  1511 				;---------------------------------------
  1512
  1513 				    ;---------------------------------------
  1514 				    ; SIO call for NCD,{MK,RM}DIR,DEL,RENAME
  1515 				    ;---------------------------------------
  1516
  1517 				    ;---------------------------------------
  1518 				    ; Get Fujinet SIO command (~ $21 for DEL)
  1519 				    ; X = table index from caller
  1520 				    ;---------------------------------------
  1521 0CA0 BD F0 15		        LDA     CMD_DCOMND,X
  1522 0CA3 8D 0B 0D		        STA     GENDCB+2
  1523
  1524 0CA6 C9 FD		        CMP     #CMD_USER       ; Skip prepending devspec for SSH
  1525 0CA8 F0 1C		        BEQ     DO_GENERIC_NEXT
  1526 0CAA C9 FE		        CMP     #CMD_PASS
  1527 0CAC F0 18		        BEQ     DO_GENERIC_NEXT
  1528
  1529 				    ;---------------------------------------
  1530 				    ; Get DOSDR from either arg1 or curr drive
  1531 				    ;---------------------------------------
  1532 0CAE 20 7D 0C		        JSR     GET_DOSDR    ; X will contain int of n in Nn:
  1533 0CB1 8E 0A 0D		        STX     GENDCB+1
  1534 0CB4 20 98 15		        JSR     PREPEND_DRIVE
  1535
  1536 				    ;---------------------------------------
  1537 				    ; If this is NCD ensure a '/' char is the last char
  1538 				    ;---------------------------------------
  1539 0CB7 AD 0B 0D		        LDA     GENDCB+2
  1540 0CBA C9 2C		        CMP     #CMD_CD         ; Is this an NCD command?
  1541 0CBC D0 08		        BNE     DO_GENERIC_NEXT ; No. skip
  1542
  1543 0CBE AD 9A 0B		        LDA     CMDSEP
  1544 0CC1 F0 2C		        BEQ     NCD_ERROR
  1545 0CC3 20 C5 15		        JSR     APPEND_SLASH    ; Append '/' to path if missing
  1546
  1547 0CC6			DO_GENERIC_NEXT:
  1548 				    ;---------------------------------------
  1549 				    ; Populate the DCB
  1550 				    ;---------------------------------------
  1551 0CC6 AD 50 17		        LDA     DOSDR
  1552 0CC9 8D 49 09		        STA     STADCB+1        ; Yes. Status (not typo)
  1553 				;        STA     GENDCB+1   ; 20221105 - commented-out. checking for bug...
  1554 0CCC A5 F3		        LDA     INBUFF
  1555 0CCE 8D 0D 0D		        STA     GENDCB+4
  1556 0CD1 A5 F4		        LDA     INBUFF+1
  1557 0CD3 8D 0E 0D		        STA     GENDCB+5
  1558
  1559 				    ;---------------------------------------
  1560 				    ; Send the command to FujiNet
  1561 				    ;---------------------------------------
  1562 0CD6 A9 09		        LDA     #<GENDCB
  1563 0CD8 A0 0D		        LDY     #>GENDCB
  1564 0CDA 20 A5 07		        JSR     DOSIOV
  1565 0CDD 20 A4 0A		        JSR     PRINT_ERROR
  1566
  1567 0CE0			GEN_UNMOUNT:
  1568 				    ;---------------------------------------
  1569 				    ; if DEL or RENAME, then remount drive
  1570 				    ;---------------------------------------
  1571 0CE0 AD 52 17		        LDA     CMDPRV
  1572 0CE3 C9 02		        CMP     #CMD_IDX.DEL
  1573 0CE5 F0 04		        BEQ     GEN_REMOUNT
  1574 0CE7 C9 09		        CMP     #CMD_IDX.RENAME
  1575 0CE9 D0 03		        BNE     GENDONE
  1576 0CEB			GEN_REMOUNT:
  1577 0CEB 4C 65 15		        JMP     REMOUNT_DRIVE
  1578
  1579 0CEE			GENDONE:
  1580 0CEE 60			        RTS
  1581
  1582 				;---------------------------------------
  1583 0CEF			NCD_ERROR:
  1584 				;---------------------------------------
  1585 0CEF A9 03		        LDA     #<NCD_ERROR_STR
  1586 0CF1 A0 0D		        LDY     #>NCD_ERROR_STR
  1587 0CF3 20 89 0A		        JSR     PRINT_STRING
  1588 0CF6 A0 01		        LDY     #$01        ; Return error
  1589 0CF8 60			        RTS
  1590 				    ;---------------------------------------
  1591 				    ; Close 
  1592 				    ;---------------------------------------
  1593 0CF9 A2 10		        LDX     #$10        ; File #1
  1594 0CFB A9 0C		        LDA     #$0C        ; Close #1 first
  1595 0CFD 9D 42 03		        STA     ICCOM,X
  1596 0D00 20 56 E4		        JSR     CIOV
  1597
  1598 0D03			NCD_ERROR_STR:
  1599 0D03 50 41 54 48 3F 9B	        .BYTE   'PATH?',EOL
  1600
  1601 				;---------------------------------------
  1602 0D09			GENDCB:
  1603 0D09 71			        .BYTE   DEVIDN      ; DDEVIC
  1604 0D0A FF			        .BYTE   $FF         ; DUNIT
  1605 0D0B FF			        .BYTE   $FF         ; DCOMND
  1606 0D0C 80			        .BYTE   $80         ; DSTATS
  1607 0D0D FF			        .BYTE   $FF         ; DBUFL
  1608 0D0E FF			        .BYTE   $FF         ; DBUFH
  1609 0D0F 1F			        .BYTE   $1F         ; DTIMLO
  1610 0D10 00			        .BYTE   $00         ; DRESVD
  1611 0D11 00			        .BYTE   $00         ; DBYTL
  1612 0D12 01			        .BYTE   $01         ; DBYTH
  1613 0D13 00			        .BYTE   $00         ; DAUX1
  1614 0D14 00			        .BYTE   $00         ; DAUX2
  1615
  1616 				; End of DO_GENERIC
  1617 				;---------------------------------------
  1618
  1619 				;;---------------------------------------
  1620 				;DO_COPY:
  1621 				;;---------------------------------------
  1622 				;
  1623 				;        LDA     #$20
  1624 				;        STA     COLOR2
  1625 				;
  1626 				;        LDA     #<CPYDCB
  1627 				;        LDY     #>CPYDCB
  1628 				;        JSR     DOSIOV
  1629 				;
  1630 				;        LDA     #$20
  1631 				;        STA     COLOR2
  1632 				;
  1633 				;        RTS
  1634 				;
  1635 				;CPYDCB:
  1636 				;        .BYTE      DEVIDN  ; DDEVIC
  1637 				;        .BYTE      $FF     ; DUNIT
  1638 				;        .BYTE      $D8     ; DCOMND
  1639 				;        .BYTE      $80     ; DSTATS
  1640 				;        .BYTE      <COPYSPEC  ; DBUFL
  1641 				;        .BYTE      >COPYSPEC ; DBUFH
  1642 				;        .BYTE      $FE     ; DTIMLO
  1643 				;        .BYTE      $00     ; DRESVD
  1644 				;        .BYTE      $00     ; DBYTL
  1645 				;        .BYTE      $01     ; DBYTH
  1646 				;        .BYTE      3       ; DAUX1
  1647 				;        .BYTE      2       ; DAUX2
  1648 				;
  1649 				;COPYSPEC:
  1650 				;        .BYTE 'iss.po|iss.po',$00
  1651
  1652 				;;---------------------------------------
  1653 				;DO_COPY:
  1654 				;;---------------------------------------
  1655 				;        LDA     #$B0
  1656 				;        STA     COLOR2
  1657 				;        RTS
  1658
  1659 				;        JSR     COPY_PARSE_FILES    ; locate comma, replace with EOL
  1660 				;        BMI     COPY_DONE
  1661 				;
  1662 				;        LDA     CMDSEP
  1663 				;        STA     CMDSEP+2
  1664 				;
  1665 				;        LDA     CMDSEP+1
  1666 				;        STA     CMDSEP
  1667 				;
  1668 				;        JSR     COPY_OPEN_DEST      ; use CIO to open file 2 for write
  1669 				;        BMI     COPY_DONE
  1670 				;
  1671 				;        LDA     CMDSEP+2
  1672 				;        STA     CMDSEP
  1673 				;        JSR     COPY_OPEN_SRC       ; use CIO to open file 1 for read
  1674 				;        BMI     COPY_DONE
  1675 				;
  1676 				;@:      JSR     COPY_GET_SRC
  1677 				;        JSR     COPY_PUT_DEST
  1678 				;        ;BNE     @-
  1679 				;
  1680 				;COPY_DONE:
  1681 				;    ; Close files
  1682 				;        LDX     #$10
  1683 				;        JSR     CIOCLOSE
  1684 				;        LDX     #$20
  1685 				;        JMP     CIOCLOSE
  1686 				;
  1687 				;;---------------------------------------
  1688 				;COPY_PARSE_FILES:
  1689 				;;---------------------------------------
  1690 				;    ; Find position of comma in line buffer
  1691 				;    ; Return X = position of comma
  1692 				;    ;---------------------------------------
  1693 				;        LDX     CMDSEP
  1694 				;COPY_PARSE_LOOP:
  1695 				;        LDA     LNBUF,X
  1696 				;        CMP     #','
  1697 				;        BEQ     COPY_PARSE_FILES_DONE
  1698 				;        CMP     #EOL
  1699 				;        BEQ     COPY_SHOW_USAGE
  1700 				;        INX
  1701 				;        BNE     COPY_PARSE_LOOP
  1702 				;COPY_PARSE_FILES_DONE:
  1703 				;    ;---------------------------------------
  1704 				;    ; Here if comma found.
  1705 				;    ; Inject EOL where the comma was found
  1706 				;    ;---------------------------------------
  1707 				;        LDA     #EOL
  1708 				;        STA     LNBUF,X
  1709 				;        INX                 ; Advance to start of 2nd arg
  1710 				;        STX     CMDSEP+1    ; Point to 2nd arg now
  1711 				;        RTS
  1712 				;    ;---------------------------------------
  1713 				;    ; Here if no comma found.
  1714 				;    ; Print usage
  1715 				;    ;---------------------------------------
  1716 				;COPY_SHOW_USAGE:
  1717 				;        LDA     #<COPY_SHOW_USAGE_STR
  1718 				;        LDY     #>COPY_SHOW_USAGE_STR
  1719 				;        JSR     PRINT_STRING
  1720 				;        LDY     #$FF
  1721 				;        RTS
  1722 				;
  1723 				;COPY_SHOW_USAGE_STR:
  1724 				;        .BYTE   'COPY SOURCE,DEST',EOL
  1725 				;
  1726 				;; End of COPY_COMMA_POS:
  1727 				;;---------------------------------------
  1728 				;
  1729 				;;---------------------------------------
  1730 				;COPY_OPEN_SRC:
  1731 				;;---------------------------------------
  1732 				;        JSR     GET_DOSDR       ; Get DUNIT
  1733 				;        JSR     PREPEND_DRIVE
  1734 				;
  1735 				;        LDX     #$10            ; File #1
  1736 				;        JSR     CIOCLOSE        ; Assert file #1 is closed
  1737 				;        LDY     #$04            ; Open for input
  1738 				;        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  1739 				;        BPL     COPY_OPEN_SRC_DONE
  1740 				;
  1741 				;        LDA     #<COPY_OPEN_SRC_ERR_STR
  1742 				;        LDY     #>COPY_OPEN_SRC_ERR_STR
  1743 				;        JMP     PRINT_STRING
  1744 				;
  1745 				;COPY_OPEN_SRC_DONE:
  1746 				;        RTS
  1747 				;        
  1748 				;COPY_OPEN_SRC_ERR_STR:
  1749 				;        .BYTE   'UNABLE TO OPEN SOURCE',EOL
  1750 				;
  1751 				;;End of COPY_OPEN_SRC
  1752 				;;---------------------------------------
  1753 				;
  1754 				;;---------------------------------------
  1755 				;COPY_OPEN_DEST:
  1756 				;;---------------------------------------
  1757 				;    ; Advance offset to arg2
  1758 				;        
  1759 				;@:      JSR     GET_DOSDR       ; Get DUNIT
  1760 				;        JSR     PREPEND_DRIVE
  1761 				;
  1762 				;        LDX     #$20            ; Assert file #2 is closed
  1763 				;        JSR     CIOCLOSE
  1764 				;
  1765 				;        LDY     #$08            ; Open for write
  1766 				;        JSR     CIOOPEN
  1767 				;        BPL     COPY_OPEN_DEST_DONE  ; If success, skip ahead
  1768 				;
  1769 				;        LDA     #<COPY_OPEN_DEST_ERR_STR
  1770 				;        LDY     #>COPY_OPEN_DEST_ERR_STR
  1771 				;        JMP     PRINT_STRING
  1772 				;
  1773 				;COPY_OPEN_DEST_DONE:
  1774 				;        RTS
  1775 				;        
  1776 				;COPY_OPEN_DEST_ERR_STR:
  1777 				;        .BYTE   'UNABLE TO OPEN DEST',EOL
  1778 				;
  1779 				;;End of COPY_OPEN_SRC
  1780 				;;---------------------------------------
  1781 				;
  1782 				;;---------------------------------------
  1783 				;COPY_GET_SRC:
  1784 				;;---------------------------------------
  1785 				;        ;LDX     #$10
  1786 				;        ;JSR     CIOSTATUS
  1787 				;
  1788 				;        LDX     #$10
  1789 				;        LDA     #<TBUF
  1790 				;        STA     INBUFF      ; Buffer addr Lo
  1791 				;        LDA     #>TBUF
  1792 				;        STA     INBUFF+1    ; Buffer addr Hi
  1793 				;        LDA     #$80        ; Buffer size Lo
  1794 				;        LDY     #$00        ; Buffer size Hi
  1795 				;        JSR     CIOGET
  1796 				;        BPL     COPY_GET_SRC_DONE
  1797 				;        CPY     #EOF
  1798 				;        BEQ     COPY_GET_SRC_DONE
  1799 				; 
  1800 				;        LDA     #<COPY_GET_SRC_STR
  1801 				;        LDY     #>COPY_GET_SRC_STR
  1802 				;        JMP     PRINT_STRING
  1803 				;
  1804 				;COPY_GET_SRC_DONE:
  1805 				;        RTS
  1806 				;
  1807 				;COPY_GET_SRC_STR:
  1808 				;        .BYTE   'ERROR READING FROM SOURCE',EOL
  1809 				;
  1810 				;;---------------------------------------
  1811 				;COPY_PUT_DEST:
  1812 				;;---------------------------------------
  1813 				;        ;LDX     #$20
  1814 				;        ;JSR     CIOSTATUS
  1815 				;
  1816 				;        LDX     #$20
  1817 				;        LDA     #<TBUF
  1818 				;        STA     INBUFF      ; Buffer addr Lo
  1819 				;        LDA     #>TBUF
  1820 				;        STA     INBUFF+1    ; Buffer addr Hi
  1821 				;        LDA     #$06        ; Buffer size Lo
  1822 				;        LDY     #$00        ; Buffer size Hi
  1823 				;        JSR     CIOPUT
  1824 				;        BPL     COPY_PUT_DEST_DONE
  1825 				;        CPY     #EOF
  1826 				;        BEQ     COPY_PUT_DEST_DONE
  1827 				; 
  1828 				;        LDA     #<COPY_PUT_DEST_STR
  1829 				;        LDY     #>COPY_PUT_DEST_STR
  1830 				;        JMP     PRINT_STRING
  1831 				;
  1832 				;COPY_PUT_DEST_DONE:
  1833 				;        RTS
  1834 				;
  1835 				;COPY_PUT_DEST_STR:
  1836 				;        .BYTE   'ERROR WRITING TO DEST',EOL
  1837 				;
  1838
  1839 				;---------------------------------------
  1840 0D15			DO_DIR:
  1841 				;---------------------------------------
  1842 0D15 20 75 0D		        JSR     DIR_INIT    ; set dunits
  1843 0D18 20 85 0D		        JSR     DIR_OPEN    ; open with dir request
  1844 0D1B C0 01		        CPY     #$01        ; success (1) ?
  1845 0D1D F0 03		        BEQ     DIR_LOOP    ; if success, jump ahead
  1846 0D1F 4C A4 0A		        JMP     PRINT_ERROR ; exit
  1847
  1848 0D22			DIR_LOOP:
  1849
  1850 				    ;---------------------------------------
  1851 				    ; Send Status request to SIO
  1852 				    ;---------------------------------------
  1853 0D22 A9 48		        LDA     #<STADCB
  1854 0D24 A0 09		        LDY     #>STADCB
  1855 0D26 20 A5 07		        JSR     DOSIOV
  1856
  1857 				    ;---------------------------------------
  1858 				    ; Status returns DVSTAT
  1859 				    ;---------------------------------------
  1860 0D29 A2 00		        LDX     #$00
  1861 0D2B EC EB 02		        CPX     DVSTAT+1    ; if byte count < 255 (that is, hi=0)
  1862 0D2E F0 09		        BEQ     DIR_LT_255  ; then skip
  1863
  1864 				    ;---------------------------------------
  1865 				    ; Branch 1: Read 255 bytes (max)
  1866 				    ;---------------------------------------
  1867 0D30 CA			        DEX                 ; X now 255 (Read FF Bytes)
  1868 0D31 8E 71 0D		        STX     DIRRDCB+8   ; DBYTL
  1869 0D34 8E 73 0D		        STX     DIRRDCB+10  ; DAUX1
  1870 0D37 30 0B		        BMI     DIR_NEXT1   ; "always" true. skip down SIO call
  1871
  1872 				    ;---------------------------------------
  1873 				    ; Branch 2: Read < 255 bytes
  1874 				    ;---------------------------------------
  1875 0D39			DIR_LT_255:
  1876 0D39 AD EA 02		        LDA     DVSTAT      ; Get count of bytes remaining
  1877 0D3C F0 6C		        BEQ     DIR_ERROR   ; If here then DVSTAT = $0000 (error)
  1878 0D3E 8D 71 0D		        STA     DIRRDCB+8   ; DBYTL
  1879 0D41 8D 73 0D		        STA     DIRRDCB+10  ; DAUX1
  1880
  1881 				    ;-------------------------
  1882 				    ; Send Read request to SIO
  1883 				    ;-------------------------
  1884 0D44			DIR_NEXT1:
  1885 0D44 A9 69		        LDA     #<DIRRDCB
  1886 0D46 A0 0D		        LDY     #>DIRRDCB
  1887 0D48 20 A5 07		        JSR     DOSIOV      ; Fetch directory listing
  1888 0D4B 20 DA 0D		        JSR     DIR_PRINT   ; xfer payload to screen
  1889
  1890 				    ;---------------------------------------
  1891 				    ; Pause output if SPACE key code found
  1892 				    ;---------------------------------------
  1893 0D4E			DIR_WAIT:
  1894 0D4E AD FC 02		        LDA     CH
  1895 0D51 C9 21		        CMP     #SPC_KEY
  1896 0D53 F0 F9		        BEQ     DIR_WAIT
  1897
  1898 				    ;---------------------------------------
  1899 				    ; Exit loop if ESC key code found
  1900 				    ;---------------------------------------
  1901 0D55 AD FC 02		        LDA     CH
  1902 0D58 C9 1C		        CMP     #ESC_KEY    ; hardware code for ESC key
  1903 0D5A F0 05		        BEQ     DIR_NEXT
  1904
  1905 				    ;---------------------------------------
  1906 				    ; Loop if more data to read
  1907 				    ;---------------------------------------
  1908 0D5C AD EB 02		        LDA     DVSTAT+1    ; Was there more to read (that is, was hi>0)?
  1909 0D5F D0 C1		        BNE     DIR_LOOP    ; If yes, then do it again
  1910
  1911 0D61			DIR_NEXT:
  1912 0D61 A9 FF		        LDA     #$FF        ; Clear key
  1913 0D63 8D FC 02		        STA     CH
  1914 0D66 4C F8 0D		        JMP     DIR_CLOSE
  1915
  1916 0D69			DIRRDCB:
  1917 0D69 71			        .BYTE   DEVIDN      ; DDEVIC
  1918 0D6A FF			        .BYTE   $FF         ; DUNIT
  1919 0D6B 52			        .BYTE   'R'         ; DCOMND
  1920 0D6C 40			        .BYTE   $40         ; DSTATS
  1921 0D6D 00			        .BYTE   <RBUF       ; DBUFL
  1922 0D6E 18			        .BYTE   >RBUF       ; DBUFH
  1923 0D6F 1F			        .BYTE   $1F         ; DTIMLO
  1924 0D70 00			        .BYTE   $00         ; DRESVD
  1925 0D71 00			        .BYTE   $00         ; DBYTL
  1926 0D72 00			        .BYTE   $00         ; DBYTH
  1927 0D73 00			        .BYTE   $00         ; DAUX1
  1928 0D74 00			        .BYTE   $00         ; DAUX2
  1929
  1930 				;---------------------------------------
  1931 				; Set DUNITs in all DCBs used by DIR
  1932 				;---------------------------------------
  1933 0D75			DIR_INIT:
  1934 				;---------------------------------------
  1935 0D75 20 7D 0C		        JSR     GET_DOSDR   ; On return, X <- n in Nn:
  1936 0D78 8E CF 0D		        STX     DIRODCB+1   ; DUNIT for Open
  1937 0D7B 8E 49 09		        STX     STADCB+1    ; DUNIT for Status
  1938 0D7E 8E 6A 0D		        STX     DIRRDCB+1   ; DUNIT for Read
  1939 0D81 8E 22 08		        STX     CLODCB+1    ; DUNIT for Close
  1940 0D84 60			        RTS
  1941
  1942 				;---------------------------------------
  1943 0D85			DIR_OPEN:
  1944 				;---------------------------------------
  1945 0D85 20 98 15		        JSR     PREPEND_DRIVE
  1946
  1947 				    ;-----------------------------------
  1948 				    ; Default to arg1
  1949 				    ;-----------------------------------
  1950 0D88 A6 F3		        LDX     INBUFF
  1951 0D8A A4 F4		        LDY     INBUFF+1
  1952
  1953 				    ;-----------------------------------
  1954 				    ; But use Nn:*.* if no arg1
  1955 				    ;-----------------------------------
  1956 0D8C AD 9A 0B		        LDA     CMDSEP          ; 0 means no arg1
  1957 0D8F D0 0C		        BNE     DIR_OPEN_NEXT   ; If arg1 present then skip
  1958
  1959 				    ;-----------------------------------
  1960 				    ; Here if no arg1
  1961 				    ;-----------------------------------
  1962 0D91 A2 C7		        LDX     #<DIR_OPEN_STR
  1963 0D93 A0 0D		        LDY     #>DIR_OPEN_STR
  1964
  1965 0D95 AD 50 17		        LDA     DOSDR
  1966 0D98 09 30		        ORA     #'0'            ; Convert, say, 1 to '1'
  1967 0D9A 8D C8 0D		        STA     DIR_OPEN_STR+1  ; Inject DOSDR into string
  1968
  1969 0D9D			DIR_OPEN_NEXT:
  1970 0D9D 8E D2 0D		        STX     DIRODCB+4       ; DBUFL
  1971 0DA0 8C D3 0D		        STY     DIRODCB+5       ; DBUFH
  1972
  1973 0DA3 A9 CE		        LDA     #<DIRODCB
  1974 0DA5 A0 0D		        LDY     #>DIRODCB
  1975 0DA7 4C A5 07		        JMP     DOSIOV
  1976
  1977 				;---------------------------------------
  1978 0DAA			DIR_ERROR:
  1979 				;---------------------------------------
  1980 0DAA A9 B4		        LDA     #<DIR_ERROR_STR
  1981 0DAC A0 0D		        LDY     #>DIR_ERROR_STR
  1982 0DAE 20 89 0A		        JSR     PRINT_STRING
  1983 0DB1 A0 01		        LDY     #$01            ; Return error
  1984 0DB3 60			        RTS
  1985
  1986 0DB4			DIR_ERROR_STR:
  1987 0DB4 55 4E 41 42 4C 45 +         .BYTE   'UNABLE TO READ DIR',EOL
  1988
  1989 0DC7			DIR_OPEN_STR:
  1990 0DC7 4E 20 3A 2A 2E 2A +         .BYTE   'N :*.*',EOL
  1991
  1992 0DCE			DIRODCB:
  1993 0DCE 71			        .BYTE   DEVIDN          ; DDEVIC
  1994 0DCF FF			        .BYTE   $FF             ; DUNIT
  1995 0DD0 4F			        .BYTE   'O'             ; DCOMND
  1996 0DD1 80			        .BYTE   $80             ; DSTATS
  1997 0DD2 FF			        .BYTE   $FF             ; DBUFL
  1998 0DD3 FF			        .BYTE   $FF             ; DBUFH
  1999 0DD4 1F			        .BYTE   $1F             ; DTIMLO
  2000 0DD5 00			        .BYTE   $00             ; DRESVD
  2001 0DD6 00			        .BYTE   $00             ; DBYTL
  2002 0DD7 01			        .BYTE   $01             ; DBYTH
  2003 0DD8 06			        .BYTE   $06             ; DAUX1
  2004 0DD9 80			        .BYTE   $80             ; DAUX2 (Long Dir)
  2005
  2006 				; End of DIR_OPEN
  2007 				;---------------------------------------
  2008
  2009 				;---------------------------------------
  2010 0DDA			DIR_PRINT:
  2011 				;---------------------------------------
  2012 				        ; Print results using CIO
  2013 0DDA A2 00		        LDX     #$00
  2014 0DDC A9 0B		        LDA     #PUTCHR
  2015 0DDE 9D 42 03		        STA     ICCOM,X
  2016
  2017 				        ; Fill out buffer loc
  2018 0DE1 A9 00		        LDA     #<RBUF
  2019 0DE3 9D 44 03		        STA     ICBAL,X
  2020 0DE6 A9 18		        LDA     #>RBUF
  2021 0DE8 9D 45 03		        STA     ICBAH,X
  2022
  2023 				        ; Fill out size loc
  2024 0DEB AD 71 0D		        LDA     DIRRDCB+8
  2025 0DEE 9D 48 03		        STA     ICBLL,X
  2026 0DF1 8A			        TXA
  2027 0DF2 9D 49 03		        STA     ICBLH,X
  2028 0DF5 4C 56 E4		        JMP     CIOV
  2029
  2030 				;---------------------------------------
  2031 0DF8			DIR_CLOSE:
  2032 				;---------------------------------------
  2033 				        ; Close
  2034 0DF8 A9 21		        LDA     #<CLODCB
  2035 0DFA A0 08		        LDY     #>CLODCB
  2036 0DFC 4C A5 07		        JMP     DOSIOV
  2037
  2038 				;---------------------------------------
  2039 0DFF			DO_LOAD:
  2040 				;---------------------------------------
  2041 				    ; Binary Loader based on work by Richard J. Kalagher 07-AUG-1983
  2042
  2043 				    ; Open file
  2044 0DFF AD 9A 0B		        LDA     CMDSEP          ; Quit if no arg1
  2045 0E02 D0 03		        BNE     LOAD_NEXT1
  2046 0E04 4C 93 10		        JMP     LOAD_ERROR
  2047
  2048 0E07			LOAD_NEXT1:
  2049 				    ; Point INBUFF to start of filename
  2050 0E07 18			        CLC
  2051 0E08 65 F3		        ADC     INBUFF          ; [A] contains offset to arg1
  2052 0E0A 85 F3		        STA     INBUFF
  2053 0E0C 90 02		        BCC     LOAD_NEXT2
  2054 0E0E E6 F4		        INC     INBUFF+1
  2055
  2056 0E10			LOAD_NEXT2:
  2057 0E10 20 A3 0E		        JSR     LOAD_NTRANS     ; Disable any EOL translation
  2058 0E13 20 5F 0E		        JSR     LOAD_SETUP      ; Set up run and init to RTS
  2059 0E16 A9 04		        LDA     #OINPUT         ; A arg needed in LOAD_OPEN
  2060 0E18 20 75 0E		        JSR     LOAD_OPEN       ; Open the file
  2061 0E1B C0 01		        CPY     #$01            ; Quit if unable to open
  2062 0E1D D0 3F		        BNE     R
  2063
  2064 0E1F A9 FF		        LDA     #$FF
  2065 0E21 8D 90 18		        STA     BIN_1ST
  2066 0E24 20 B1 0E		        JSR     LOAD_READ2
  2067 0E27 20 D2 0E		        JSR     LOAD_CHKFF
  2068 0E2A C0 01		        CPY     #$01
  2069 0E2C D0 30		        BNE     R
  2070
  2071 0E2E EE 90 18		        INC     BIN_1ST
  2072 				    ; Process each payload
  2073 0E31 20 B1 0E		GETFIL: JSR     LOAD_READ2      ; Get two bytes (binary header)
  2074 0E34 30 28		        BMI     R               ; Exit if EOF hit
  2075 0E36 20 6A 0E		        JSR     LOAD_INIT       ; Set init default
  2076 0E39 A2 01		        LDX     #$01
  2077 0E3B 20 D2 0E		        JSR     LOAD_CHKFF      ; Check if header (and start addr, too)
  2078 0E3E 20 09 0F		        JSR     LOAD_STRAD      ; Put start address in
  2079 0E41 20 B1 0E		        JSR     LOAD_READ2      ; Get to more butes (end addr)
  2080 0E44 20 16 0F		        JSR     LOAD_ENDAD      ; Put end address in
  2081 0E47 20 2F 0F		        JSR     LOAD_BUFLEN     ; Calculate buffer length
  2082 0E4A 20 54 0F		        JSR     LOAD_GETDAT     ; Get the data record
  2083 0E4D 10 03		        BPL     @+              ; Was EOF detected?
  2084 0E4F 20 5B 0E		        JSR     JSTART          ; Yes. Go to RUNAD
  2085 0E52 20 58 0E		@:      JSR     JINIT           ; Attempt initialization
  2086 0E55 4C 31 0E		        JMP     GETFIL          ; Process next payload
  2087
  2088 0E58 6C E2 02		JINIT:  JMP     (INITAD)        ; Will either RTS or perform INIT
  2089 0E5B 6C E0 02		JSTART: JMP     (RUNAD)         ; Godspeed.
  2090 0E5E 60			R:      RTS                     ; Stunt-double for (INITAD),(RUNAD)
  2091
  2092 				;---------------------------------------
  2093 0E5F			LOAD_SETUP:
  2094 				;---------------------------------------
  2095 0E5F A9 5E		        LDA     #<R
  2096 0E61 8D E0 02		        STA     RUNAD
  2097 0E64 A9 0E		        LDA     #>R
  2098 0E66 8D E1 02		        STA     RUNAD+1
  2099 0E69 60			        RTS
  2100
  2101 				;---------------------------------------
  2102 0E6A			LOAD_INIT:
  2103 				;---------------------------------------
  2104 0E6A A9 5E		        LDA     #<R
  2105 0E6C 8D E2 02		        STA     INITAD
  2106 0E6F A9 0E		        LDA     #>R
  2107 0E71 8D E3 02		        STA     INITAD+1
  2108 0E74 60			        RTS
  2109
  2110 				;---------------------------------------
  2111 0E75			LOAD_OPEN:
  2112 				;---------------------------------------
  2113 0E75 48			        PHA                     ; Save data direction passed in A
  2114 0E76 20 7D 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2115 0E79 8E 01 08		        STX     OPNDCB+1        ; Set DUNIT
  2116 0E7C 8E 83 08		        STX     GETDCB+1        ; Set DUNIT FOR READ
  2117 0E7F 20 98 15		        JSR     PREPEND_DRIVE
  2118
  2119 0E82 A5 F3		        LDA     INBUFF          ; Register location of filename
  2120 0E84 8D 04 08		        STA     OPNDCB+4
  2121 0E87 A5 F4		        LDA     INBUFF+1
  2122 0E89 8D 05 08		        STA     OPNDCB+5
  2123
  2124 0E8C 68			        PLA                     ; A = data direction (4=in, 8=out)
  2125 0E8D 8D 0A 08		        STA     OPNDCB+10
  2126 0E90 A9 00		        LDA     #$00            ; AUX2: No translation
  2127 0E92 8D 0B 08		        STA     OPNDCB+11
  2128
  2129 0E95 A9 00		        LDA     #<OPNDCB
  2130 0E97 A0 08		        LDY     #>OPNDCB
  2131 0E99 20 A5 07		        JSR     DOSIOV
  2132
  2133 0E9C 48			        PHA
  2134 0E9D 20 A4 0A		        JSR     PRINT_ERROR
  2135 0EA0 68			        PLA
  2136 0EA1 A8			        TAY
  2137
  2138 0EA2 60			        RTS
  2139
  2140 				;---------------------------------------
  2141 0EA3			LOAD_NTRANS:
  2142 				;---------------------------------------
  2143 				    ; Disable any EOL transation otherwise
  2144 				    ; binary data will be corrupted during load
  2145 				    ;---------------------------------------
  2146 0EA3 20 7D 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2147 0EA6 8E 5B 11		        STX     NTRDCB+1        ; Set DUNIT
  2148 0EA9 A9 00		        LDA     #$00
  2149 0EAB 8D 65 11		        STA     NTRDCB+11       ; Translation mode (0 = NONE)
  2150 0EAE 4C 27 11		        JMP     NTRANS_CALL     ; Reuse code in DO_NTRANS
  2151
  2152 				;---------------------------------------
  2153 0EB1			LOAD_READ2:
  2154 				;---------------------------------------
  2155 				    ; Load 2 bytes into Buffer (BAL/H).
  2156 				    ;---------------------------------------
  2157 				    ; This is accomplished by abusing the LOAD_GETDAT
  2158 				    ; routine by stuffing the buffer addr (BAL/H)
  2159 				    ; into the payload Start/End addrs. We're doing
  2160 				    ; this in case a payload  header straddles a
  2161 				    ; cache boundary. LOAD_GETDAT has the logic for
  2162 				    ; dealing with that.
  2163 				    ;---------------------------------------
  2164 0EB1 A9 00		        LDA     #<BAL
  2165 0EB3 8D 80 18		        STA     STL         ; Payload start address
  2166 0EB6 A9 18		        LDA     #>BAL
  2167 0EB8 8D 81 18		        STA     STH
  2168
  2169 0EBB A9 01		        LDA     #<BAH
  2170 0EBD 8D 82 18		        STA     ENL         ; Payload end address
  2171 0EC0 A9 18		        LDA     #>BAH
  2172 0EC2 8D 83 18		        STA     ENH
  2173
  2174 0EC5 A2 02		        LDX     #$02
  2175 0EC7 8E 84 18		        STX     BLL         ; Payload size (2)
  2176 0ECA A9 00		        LDA     #$00
  2177 0ECC 8D 85 18		        STA     BLH
  2178
  2179 0ECF 4C 54 0F		        JMP     LOAD_GETDAT ; Read 2 bytes
  2180
  2181 				;---------------------------------------
  2182 0ED2			LOAD_CHKFF:
  2183 				;---------------------------------------
  2184 				    ; On 1st pass, check for binary signature (FF FF)
  2185 				    ; On 2..n passes, Skip FF FF (if found) 
  2186 				    ; and read next 2 bytes
  2187 				    ;---------------------------------------
  2188 				        
  2189 0ED2 A9 FF		        LDA     #$FF
  2190 0ED4 CD 00 18		        CMP     BAL         ; Is 1st byte FF?
  2191 0ED7 D0 0D		        BNE     NOTFF       ; If no, skip down.
  2192 0ED9 CD 01 18		        CMP     BAH         ; Is 2nd byte FF?
  2193 0EDC D0 08		        BNE     NOTFF       ; If no, skip down.
  2194
  2195 				    ;---------------------------------------
  2196 				    ; Here if FF FF tags found. 
  2197 				    ; On 1st pass, we're done.
  2198 				    ; On 2..n passes, read next 2 bytes and leave.
  2199 				    ;---------------------------------------
  2200 0EDE CD 90 18		        CMP     BIN_1ST     ; Is this 1st pass?
  2201 0EE1 F0 13		        BEQ     NOTFF_DONE  ; If yes, then we're done here.
  2202 0EE3 4C B1 0E		        JMP     LOAD_READ2  ; 
  2203
  2204 				    ;---------------------------------------
  2205 				    ; Here if FF FF tags NOT found. 
  2206 				    ; On 1st pass, print error.
  2207 				    ; On 2..n passes, the 2 bytes = payload start addr.
  2208 				    ;---------------------------------------
  2209 0EE6 A0 01		NOTFF:  LDY     #$01        ; Preload success return code
  2210 0EE8 CD 90 18		        CMP     BIN_1ST     ; A still has FF. BIN_1ST = FF on first pass
  2211 0EEB D0 09		        BNE     NOTFF_DONE  ; Not 1st pass, exit with success.
  2212
  2213 0EED			NOTFF_ERR:
  2214 0EED A9 F7		        LDA     #<LOAD_ERROR_STR2
  2215 0EEF A0 0E		        LDY     #>LOAD_ERROR_STR2
  2216 0EF1 20 89 0A		        JSR     PRINT_STRING
  2217
  2218 0EF4 A0 FF		        LDY     #$FF        ; Return failure
  2219 0EF6			NOTFF_DONE:
  2220 0EF6 60			        RTS
  2221
  2222 0EF7			LOAD_ERROR_STR2:
  2223 0EF7 4E 4F 54 20 41 20 +         .BYTE   'NOT A BINARY FILE',EOL
  2224
  2225 				;---------------------------------------
  2226 0F09			LOAD_STRAD:
  2227 				;---------------------------------------
  2228 				    ; Save payload start address into STL2/STLH2.
  2229 				    ; Otherwise it will get clobbered
  2230 				    ; when reading payload end address.
  2231 0F09 AD 00 18		        LDA     RBUF
  2232 0F0C 8D 8E 18		        STA     STL2
  2233 0F0F AD 01 18		        LDA     RBUF+1
  2234 0F12 8D 8F 18		        STA     STH2
  2235 0F15 60			        RTS
  2236
  2237 				;---------------------------------------
  2238 0F16			LOAD_ENDAD:
  2239 				;---------------------------------------
  2240 				    ; Save payload end address
  2241 0F16 AD 8E 18		        LDA     STL2
  2242 0F19 8D 80 18		        STA     STL
  2243 0F1C AD 8F 18		        LDA     STH2
  2244 0F1F 8D 81 18		        STA     STH
  2245 				    
  2246 0F22 AD 00 18		        LDA     RBUF
  2247 0F25 8D 82 18		        STA     ENL
  2248 0F28 AD 01 18		        LDA     RBUF+1
  2249 0F2B 8D 83 18		        STA     ENH
  2250 0F2E 60			        RTS
  2251
  2252 				;---------------------------------------
  2253 0F2F			LOAD_BUFLEN:
  2254 				;---------------------------------------
  2255 				    ; Calculate buffer length (end-start+1)
  2256
  2257 				    ; Calc buffer size Lo
  2258 0F2F AD 82 18		        LDA     ENL
  2259 0F32 38			        SEC
  2260 0F33 ED 80 18		        SBC     STL
  2261 0F36 8D 84 18		        STA     BLL     ; Buffer Length Lo
  2262
  2263 				    ; Calc buffer size Hi
  2264 0F39 AD 83 18		        LDA     ENH     ; Calc buffer size Hi
  2265 0F3C ED 81 18		        SBC     STH
  2266 0F3F 8D 85 18		        STA     BLH     ; Buffer Length Hi
  2267
  2268 				    ; Add 1
  2269 0F42 18			        CLC
  2270 0F43 AD 84 18		        LDA     BLL
  2271 0F46 69 01		        ADC     #$01
  2272 0F48 8D 84 18		        STA     BLL
  2273
  2274 0F4B AD 85 18		        LDA     BLH
  2275 0F4E 69 00		        ADC     #$00    ; Take care of any carry
  2276 0F50 8D 85 18		        STA     BLH
  2277
  2278 0F53 60			        RTS
  2279
  2280 				;;---------------------------------------
  2281 				;LOAD_GETDAT:
  2282 				;;---------------------------------------
  2283 				;
  2284 				;    ;---------------------------------------
  2285 				;    ; Fill out the DCB
  2286 				;    ;---------------------------------------
  2287 				;        JSR     GET_DOSDR
  2288 				;        STX     BINDCB+1        ; DUNIT
  2289 				;
  2290 				;        LDA     STL
  2291 				;        STA     BINDCB+4        ; DBUFL 
  2292 				;        LDA     STH
  2293 				;        STA     BINDCB+5        ; DBUFH
  2294 				;        LDA     BLL
  2295 				;        STA     BINDCB+8        ; DBYTL
  2296 				;        STA     BINDCB+10
  2297 				;        LDA     BLH
  2298 				;        STA     BINDCB+9        ; DBYTH
  2299 				;        STA     BINDCB+11
  2300 				;
  2301 				;    ;---------------------------------------
  2302 				;    ; Send Read request to SIO
  2303 				;    ;---------------------------------------
  2304 				;        LDA     #<BINDCB
  2305 				;        LDY     #>BINDCB
  2306 				;        JSR     DOSIOV
  2307 				;        JSR     PRINT_ERROR     ; Show any errors
  2308 				;
  2309 				;    ;---------------------------------------
  2310 				;    ; Get status (updates DVSTAT, DSTATS)
  2311 				;    ;---------------------------------------
  2312 				;        LDA     BINDCB+1
  2313 				;        STA     STADCB+1
  2314 				;        LDA     #<STADCB
  2315 				;        LDY     #>STADCB
  2316 				;        JSR     DOSIOV
  2317 				;
  2318 				;    ; Check if EOF (current requested chunk completed?)
  2319 				;        LDA     #EOF
  2320 				;        CMP     DVSTAT+3
  2321 				;        BEQ     LOAD_GETDAT_DONE
  2322 				;        JMP     PRINT_ERROR
  2323 				;
  2324 				;LOAD_GETDAT_DONE:
  2325 				;    ; Check if 0 bytes remaining
  2326 				;        LDA     DVSTAT
  2327 				;        BNE     LOAD_GETDAT_DONE2
  2328 				;        LDA     DVSTAT+1
  2329 				;        BNE     LOAD_GETDAT_DONE2
  2330 				;        LDY     #$FF
  2331 				;        RTS
  2332 				;
  2333 				;LOAD_GETDAT_DONE2:
  2334 				;        LDY     #$01            ; Return success
  2335 				;        RTS
  2336 				;        
  2337 				;BINDCB:
  2338 				;       .BYTE    DEVIDN      ; DDEVIC
  2339 				;       .BYTE    $FF         ; DUNIT
  2340 				;       .BYTE    'R'         ; DCOMND
  2341 				;       .BYTE    $40         ; DSTATS
  2342 				;       .BYTE    $FF         ; DBUFL
  2343 				;       .BYTE    $FF         ; DBUFH
  2344 				;       .BYTE    $0F         ; DTIMLO
  2345 				;       .BYTE    $00         ; DRESVD
  2346 				;       .BYTE    $FF         ; DBYTL
  2347 				;       .BYTE    $FF         ; DBYTH
  2348 				;       .BYTE    $FF         ; DAUX1
  2349 				;       .BYTE    $FF         ; DAUX2
  2350
  2351 				;---------------------------------------
  2352 0F54			LOAD_GETDAT:
  2353 				;---------------------------------------
  2354 				    ; Definitions:
  2355 				    ; HEAD = requested bytes that will be found in current cache (< 512 bytes)
  2356 				    ; BODY = contiguous 512 byte sections. BODY = n * 512 bytes)
  2357 				    ; TAIL = any bytes remaining after BODY (< 512 bytes)
  2358
  2359 0F54 20 7D 0C		        JSR     GET_DOSDR
  2360 0F57 8E 7B 10		        STX     BINDCB+1
  2361
  2362 0F5A 20 56 10		        JSR     GETDAT_CHECK_EOF    ; Check EOF before proceeding
  2363 0F5D 10 01		        BPL     GETDAT_NEXT1        ; If true, then EOF found. Exit
  2364 0F5F 60			        RTS
  2365
  2366 				    ; Check if bytes requested BL < DVSTAT (bytes waiting in cache)
  2367 0F60			GETDAT_NEXT1:
  2368 0F60 AD EA 02		        LDA     DVSTAT
  2369 0F63 CD 84 18		        CMP     BLL
  2370 0F66 AD EB 02		        LDA     DVSTAT+1
  2371 0F69 ED 85 18		        SBC     BLH
  2372 0F6C B0 4C		        BCS     GETDAT_OPT2     ; BL <= BW (bytes waiting)
  2373
  2374 0F6E			GETDAT_OPT1:
  2375 				    ;--------------------------------
  2376 				    ; Here if bytes requested > bytes 
  2377 				    ; remaining in cache
  2378 				    ;--------------------------------
  2379
  2380 				    ;-------------------------------
  2381 				    ; Head = BW (bytes waiting)
  2382 				    ;-------------------------------
  2383 0F6E AD EA 02		        LDA     DVSTAT
  2384 0F71 8D 86 18		        STA     HEADL
  2385 0F74 AD EB 02		        LDA     DVSTAT+1
  2386 0F77 8D 87 18		        STA     HEADH
  2387
  2388 				    ;-------------------------------
  2389 				    ; Tail = (BL - HEAD) mod 512
  2390 				    ;-------------------------------
  2391 0F7A 38			        SEC
  2392 0F7B AD 84 18		        LDA     BLL
  2393 0F7E ED 86 18		        SBC     HEADL
  2394 0F81 29 FF		        AND     #$FF
  2395 0F83 8D 8A 18		        STA     TAILL
  2396 0F86 AD 85 18		        LDA     BLH
  2397 0F89 ED 87 18		        SBC     HEADH
  2398 0F8C 29 01		        AND     #$01
  2399 0F8E 8D 8B 18		        STA     TAILH
  2400
  2401 				    ;-----------------------------------
  2402 				    ; Body = BL - HEAD - TAIL
  2403 				    ;-----------------------------------
  2404 				        ; 1. Body = BL - HEAD
  2405 				        ;-------------------------------
  2406 0F91 38			        SEC
  2407 0F92 AD 84 18		        LDA     BLL
  2408 0F95 ED 86 18		        SBC     HEADL
  2409 0F98 8D 88 18		        STA     BODYL
  2410 0F9B AD 85 18		        LDA     BLH
  2411 0F9E ED 87 18		        SBC     HEADH
  2412 0FA1 8D 89 18		        STA     BODYH
  2413
  2414 				        ;-------------------------------
  2415 				        ; 2. Body = Body - HEAD
  2416 				        ;-------------------------------
  2417 0FA4 38			        SEC
  2418 0FA5 AD 88 18		        LDA     BODYL
  2419 0FA8 ED 8A 18		        SBC     TAILL
  2420 0FAB 8D 88 18		        STA     BODYL
  2421 0FAE AD 89 18		        LDA     BODYH
  2422 0FB1 ED 8B 18		        SBC     TAILH
  2423 0FB4 8D 89 18		        STA     BODYH
  2424
  2425 0FB7 4C D4 0F		        JMP     GETDAT_READ
  2426
  2427 0FBA			GETDAT_OPT2:
  2428 				    ;--------------------------------
  2429 				    ; Here if bytes requested <= bytes 
  2430 				    ; remaining in cache
  2431 				    ;--------------------------------
  2432 				    ; Head = BL, TAIL = BODY = 0
  2433 				    ;--------------------------------
  2434 0FBA AD 84 18		        LDA     BLL
  2435 0FBD 8D 86 18		        STA     HEADL
  2436 0FC0 AD 85 18		        LDA     BLH
  2437 0FC3 8D 87 18		        STA     HEADH
  2438 0FC6 A9 00		        LDA     #$00
  2439 0FC8 8D 8A 18		        STA     TAILL
  2440 0FCB 8D 8B 18		        STA     TAILH
  2441 0FCE 8D 88 18		        STA     BODYL
  2442 0FD1 8D 89 18		        STA     BODYH
  2443
  2444 				;---------------------------------------
  2445 0FD4			GETDAT_READ:
  2446 				;---------------------------------------
  2447 				    ;---------------------------------------
  2448 				    ; Read HEAD bytes
  2449 				    ;---------------------------------------
  2450 0FD4 AD 86 18		        LDA     HEADL
  2451 0FD7 8D 84 18		        STA     BLL
  2452 0FDA AD 87 18		        LDA     HEADH
  2453 0FDD 8D 85 18		        STA     BLH
  2454 0FE0 20 11 10		        JSR     GETDAT_DOSIOV
  2455 0FE3 10 01		        BPL     GETDAT_BODY ; Skip ahead if no problems
  2456 0FE5 60			        RTS                 ; Bail if error
  2457
  2458 				    ;---------------------------------------
  2459 				    ; Read BODY bytes
  2460 				    ;---------------------------------------
  2461 0FE6			GETDAT_BODY:
  2462 0FE6 AE 89 18		        LDX     BODYH
  2463 0FE9			GETDAT_BODY_LOOP:
  2464 0FE9 F0 1A		        BEQ     GETDAT_TAIL ; Skip if less than a page to read
  2465
  2466 0FEB A9 00		        LDA     #$00
  2467 0FED 8D 84 18		        STA     BLL         ; Buffer length
  2468 0FF0 A9 02		        LDA     #$02        ; 512 bytes at a time
  2469 0FF2 8D 85 18		        STA     BLH
  2470
  2471 0FF5 8A			        TXA                 ; Stash our loop index (X)
  2472 0FF6 48			        PHA                 ; onto the stack
  2473 0FF7 20 11 10		        JSR     GETDAT_DOSIOV   
  2474 0FFA 10 03		        BPL     @+          ; Skip ahead if no problems
  2475 0FFC 68			        PLA                 ; Here if problem. Clean up stack
  2476 0FFD 98			        TYA                 ; Reset N status flag before returning
  2477 0FFE 60			        RTS                 ; Bail if error
  2478
  2479 0FFF 68			@:      PLA                 ; Retrieve our loop index
  2480 1000 AA			        TAX                 ; and xfer it back into X
  2481 1001 CA			        DEX                 ; -2 (we pull 0200 bytes at a time)
  2482 1002 CA			        DEX                 ; 
  2483 1003 D0 E4		        BNE     GETDAT_BODY_LOOP
  2484
  2485 1005			GETDAT_TAIL:
  2486 				    ;---------------------------------------
  2487 				    ; Read TAIL bytes
  2488 				    ;---------------------------------------
  2489 1005 AD 8A 18		        LDA     TAILL
  2490 1008 8D 84 18		        STA     BLL
  2491 100B AD 8B 18		        LDA     TAILH
  2492 100E 8D 85 18		        STA     BLH
  2493
  2494 				;---------------------------------------
  2495 1011			GETDAT_DOSIOV:
  2496 				;---------------------------------------
  2497 				    ; Bail if BL = 0
  2498 1011 AD 84 18		        LDA     BLL
  2499 1014 D0 05		        BNE     @+
  2500 1016 AD 85 18		        LDA     BLH
  2501 1019 F0 5C		        BEQ     CHECK_EOF_DONE
  2502
  2503 				@:
  2504 				    ; SIO READ
  2505 101B AD 80 18		        LDA     STL
  2506 101E 8D 7E 10		        STA     BINDCB+4    ; Start Address Lo
  2507 1021 AD 81 18		        LDA     STH
  2508 1024 8D 7F 10		        STA     BINDCB+5    ; Start Address Hi
  2509 1027 AD 84 18		        LDA     BLL
  2510 102A 8D 82 10		        STA     BINDCB+8    ; Buffer Size Lo
  2511 102D 8D 84 10		        STA     BINDCB+10
  2512 1030 AD 85 18		        LDA     BLH
  2513 1033 8D 83 10		        STA     BINDCB+9    ; Buffer Size Hi
  2514 1036 8D 85 10		        STA     BINDCB+11
  2515
  2516 				    ;---------------------------------------
  2517 				    ; Send Read request to SIO
  2518 				    ;---------------------------------------
  2519 1039 A9 7A		        LDA     #<BINDCB
  2520 103B A0 10		        LDY     #>BINDCB
  2521 103D 20 A5 07		        JSR     DOSIOV
  2522 1040 20 A4 0A		        JSR     PRINT_ERROR
  2523
  2524 				    ;---------------------------------------
  2525 				    ; Advance start address by buffer length
  2526 				    ;---------------------------------------
  2527 1043 18			        CLC
  2528 1044 AD 80 18		        LDA     STL
  2529 1047 6D 84 18		        ADC     BLL
  2530 104A 8D 80 18		        STA     STL
  2531
  2532 104D AD 81 18		        LDA     STH
  2533 1050 6D 85 18		        ADC     BLH
  2534 1053 8D 81 18		        STA     STH
  2535
  2536 1056			GETDAT_CHECK_EOF:
  2537 				    ; Get status (updates DVSTAT, DSTATS)
  2538 1056 AD 7B 10		        LDA     BINDCB+1
  2539 1059 8D 49 09		        STA     STADCB+1
  2540 105C A9 48		        LDA     #<STADCB
  2541 105E A0 09		        LDY     #>STADCB
  2542 1060 20 A5 07		        JSR     DOSIOV
  2543
  2544 				    ; Return -1 if DVSTAT == $0000 and DVSTAT+3 == EOF
  2545 1063 AD EA 02		        LDA     DVSTAT
  2546 1066 D0 0F		        BNE     CHECK_EOF_DONE
  2547
  2548 1068 AD EB 02		        LDA     DVSTAT+1
  2549 106B D0 0A		        BNE     CHECK_EOF_DONE
  2550
  2551 106D A9 88		        LDA     #EOF
  2552 106F CD ED 02		        CMP     DVSTAT+3        ; Is it EOF
  2553 1072 D0 03		        BNE     CHECK_EOF_DONE  ; No? Go to success
  2554 1074 A0 FF		        LDY     #$FF            ; Yes? Return -1
  2555 1076 60			        RTS
  2556
  2557 1077			CHECK_EOF_DONE:
  2558 1077 A0 01		        LDY     #$01        ; Return success
  2559 1079 60			        RTS
  2560
  2561 107A			BINDCB:
  2562 107A 71			       .BYTE    DEVIDN      ; DDEVIC
  2563 107B FF			       .BYTE    $FF         ; DUNIT
  2564 107C 52			       .BYTE    'R'         ; DCOMND
  2565 107D 40			       .BYTE    $40         ; DSTATS
  2566 107E FF			       .BYTE    $FF         ; DBUFL
  2567 107F FF			       .BYTE    $FF         ; DBUFH
  2568 1080 0F			       .BYTE    $0F         ; DTIMLO
  2569 1081 00			       .BYTE    $00         ; DRESVD
  2570 1082 FF			       .BYTE    $FF         ; DBYTL
  2571 1083 FF			       .BYTE    $FF         ; DBYTH
  2572 1084 FF			       .BYTE    $FF         ; DAUX1
  2573 1085 FF			       .BYTE    $FF         ; DAUX2
  2574
  2575
  2576 				;---------------------------------------
  2577 1086			LOAD_CLOSE:
  2578 				;---------------------------------------
  2579 1086 AD 7B 10		        LDA     BINDCB+1
  2580 1089 8D 22 08		        STA     CLODCB+1
  2581 108C A9 21		        LDA     #<CLODCB
  2582 108E A0 08		        LDY     #>CLODCB
  2583 1090 4C A5 07		        JMP     DOSIOV
  2584
  2585 				;---------------------------------------
  2586 1093			LOAD_ERROR:
  2587 				;---------------------------------------
  2588 1093 A9 4A		        LDA     #<MISSING_FILE_STR
  2589 1095 A0 17		        LDY     #>MISSING_FILE_STR
  2590 1097 4C 89 0A		        JMP     PRINT_STRING
  2591
  2592 				;;---------------------------------------
  2593 				;DO_LOCK:
  2594 				;;---------------------------------------
  2595 				;        LDA     #$60
  2596 				;        STA     COLOR2
  2597 				;        RTS
  2598
  2599
  2600 				;---------------------------------------
  2601 109A			DO_LPR:
  2602 				;---------------------------------------
  2603 109A A9 B0		        LDA     #$B0
  2604 109C 8D C6 02		        STA     COLOR2
  2605 109F 60			        RTS
  2606
  2607 				;---------------------------------------
  2608 10A0			DO_NPWD:
  2609 				;---------------------------------------
  2610 10A0 A9 9B		        LDA     #EOL        ; Truncate buffer
  2611 10A2 8D 00 18		        STA     RBUF
  2612
  2613 10A5 20 7D 0C		        JSR     GET_DOSDR   ; X will contain n in Nn:
  2614 10A8 8E D8 10		        STX     PWDDCB+1
  2615
  2616 10AB A9 D7		        LDA     #<PWDDCB
  2617 10AD A0 10		        LDY     #>PWDDCB
  2618 10AF 20 A5 07		        JSR     DOSIOV
  2619 10B2 20 A4 0A		        JSR     PRINT_ERROR
  2620
  2621 				    ;---------------------------------------
  2622 				    ; If we entered DO_NPWD from REMOUNT_DRIVE
  2623 				    ; then scipt printing output
  2624 				    ;---------------------------------------
  2625 10B5 AD 52 17		        LDA     CMDPRV
  2626 10B8 C9 02		        CMP     #CMD_IDX.DEL
  2627 10BA F0 1A		        BEQ     NPWD_DONE
  2628 10BC C9 09		        CMP     #CMD_IDX.RENAME
  2629 10BE F0 16		        BEQ     NPWD_DONE
  2630
  2631 10C0			NPWD_LOOP:
  2632 10C0 A9 00		        LDA     #<RBUF
  2633 10C2 A0 18		        LDY     #>RBUF
  2634 10C4 20 89 0A		        JSR     PRINT_STRING
  2635
  2636 10C7 A9 48		        LDA     #<STADCB
  2637 10C9 A0 09		        LDY     #>STADCB
  2638 10CB 20 A5 07		        JSR     DOSIOV
  2639 10CE 20 A4 0A		        JSR     PRINT_ERROR
  2640
  2641 				    ;---------------------------------------
  2642 				    ; Loop if more data to read
  2643 				    ;---------------------------------------
  2644 10D1 AD EB 02		        LDA     DVSTAT+1    ; Was there more to read (that is, was hi>0)?
  2645 10D4 D0 EA		        BNE     NPWD_LOOP   ; If yes, then do it again
  2646
  2647 10D6			NPWD_DONE:
  2648 10D6 60			        RTS
  2649
  2650 10D7			PWDDCB:
  2651 10D7 71			        .BYTE   DEVIDN      ; DDEVIC
  2652 10D8 FF			        .BYTE   $FF         ; DUNIT
  2653 10D9 30			        .BYTE   $30         ; DCOMND
  2654 10DA 40			        .BYTE   $40         ; DSTATS
  2655 10DB 00			        .BYTE   <RBUF       ; DBUFL
  2656 10DC 18			        .BYTE   >RBUF       ; DBUFH
  2657 10DD 1F			        .BYTE   $1F         ; DTIMLO
  2658 10DE 00			        .BYTE   $00         ; DRESVD
  2659 10DF 00			        .BYTE   $00         ; DBYTL
  2660 10E0 01			        .BYTE   $01         ; DBYTH
  2661 10E1 00			        .BYTE   $00         ; DAUX1
  2662 10E2 00			        .BYTE   $00         ; DAUX2
  2663
  2664 				; End of DO_NPWD
  2665 				;---------------------------------------
  2666
  2667 				;---------------------------------------
  2668 10E3			DO_NTRANS:
  2669 				;---------------------------------------
  2670 10E3 AE 9A 0B		        LDX     CMDSEP          ; Check if there's any args
  2671 10E6 F0 49		        BEQ     NTRANS_ERROR    ; No. Show usage and quit
  2672
  2673 10E8 AD 50 17		        LDA     DOSDR           ; Go with current drive for now
  2674 10EB 8D 5B 11		        STA     NTRDCB+1        ; it'll be overwritten later if req'd
  2675
  2676 				    ;---------------------------------------
  2677 				    ; Check for argc = 2
  2678 				    ;---------------------------------------
  2679 10EE AC 9A 0B		        LDY     CMDSEP          ; Stash offset to arg1 in Y
  2680 10F1 AE 9B 0B		        LDX     CMDSEP+1        ; Is there an arg2?
  2681 10F4 F0 21		        BEQ     PARSE_MODE      ; No. parse arg1 as mode (0-3)
  2682
  2683 				    ;---------------------------------------
  2684 				    ; Here if argc = 2 (arg1 = Nn: arg2 = mode)
  2685 				    ;---------------------------------------
  2686 10F6 AE 9A 0B		        LDX     CMDSEP          ; Get offset to arg1 (Nn:)
  2687 10F9 BD 82 05		        LDA     LNBUF,X         ; Is arg1's (N[n]:) 1st char = 'N'?
  2688 10FC C9 4E		        CMP     #'N'            ;
  2689 10FE D0 31		        BNE     NTRANS_ERROR    ; No? Then quit
  2690 1100 BD 83 05		        LDA     LNBUF+1,X
  2691 1103 C9 3A		        CMP     #':'            ; Is arg1's (N[n]:) 2nd char = ':'?
  2692 1105 F0 10		        BEQ     PARSE_MODE      ; Yes, stick with default drive
  2693
  2694 				    ;---------------------------------------
  2695 				    ; Parse drive number
  2696 				    ;---------------------------------------
  2697 1107 C9 31		        CMP     #'1'            ; Quit if n in Nn not 1..4
  2698 1109 90 26		        BCC     NTRANS_ERROR    ; Quit if < '1'
  2699 110B C9 39		        CMP     #'9'
  2700 110D B0 22		        BCS     NTRANS_ERROR    ; Quit if >= '9'
  2701 110F 49 30		        EOR     #%00110000
  2702 1111 8D 5B 11		        STA     NTRDCB+1
  2703 1114 AC 9B 0B		        LDY     CMDSEP+1
  2704
  2705 				    ;---------------------------------------
  2706 				    ; Confirm valid parameter
  2707 				    ;---------------------------------------
  2708 1117			PARSE_MODE:
  2709 1117 B9 82 05		        LDA     LNBUF,Y         ; Quit if mode not 0..3
  2710 111A C9 30		        CMP     #'0'
  2711 111C 90 13		        BCC     NTRANS_ERROR
  2712 111E C9 34		        CMP     #'4'
  2713 1120 B0 0F		        BCS     NTRANS_ERROR
  2714 1122 49 30		        EOR     #%00110000      ; Here if valid parameter
  2715 1124 8D 65 11		        STA     NTRDCB+11       ; Assign parameter to DCB
  2716
  2717 				    ;---------------------------------------
  2718 				    ; Call SIO
  2719 				    ;---------------------------------------
  2720 1127			NTRANS_CALL:
  2721 1127 A9 5A		        LDA     #<NTRDCB
  2722 1129 A0 11		        LDY     #>NTRDCB
  2723 112B 20 A5 07		        JSR     DOSIOV
  2724 112E 4C A4 0A		        JMP     PRINT_ERROR
  2725
  2726 1131			NTRANS_ERROR:
  2727 1131 A9 38		        LDA     #<NTRANS_ERROR_STR
  2728 1133 A0 11		        LDY     #>NTRANS_ERROR_STR
  2729 1135 4C 89 0A		        JMP     PRINT_STRING
  2730
  2731 1138			NTRANS_ERROR_STR:
  2732 1138 4D 4F 44 45 3F 20 +         .BYTE   'MODE? 0=NONE, 1=CR, 2=LF, 3=CR/LF',EOL
  2733
  2734 115A			NTRDCB:
  2735 115A 71			        .BYTE   DEVIDN  ; DDEVIC
  2736 115B FF			        .BYTE   $FF     ; DUNIT
  2737 115C 54			        .BYTE   'T'     ; DCOMND
  2738 115D 00			        .BYTE   $00     ; DSTATS
  2739 115E 00			        .BYTE   $00     ; DBUFL
  2740 115F 00			        .BYTE   $00     ; DBUFH
  2741 1160 1F			        .BYTE   $1F     ; DTIMLO
  2742 1161 00			        .BYTE   $00     ; DRESVD
  2743 1162 00			        .BYTE   $00     ; DBYTL
  2744 1163 00			        .BYTE   $00     ; DBYTH
  2745 1164 00			        .BYTE   $00     ; DAUX1
  2746 1165 00			        .BYTE   $00     ; DAUX2
  2747
  2748 				; End of DO_NTRANS
  2749 				;---------------------------------------
  2750
  2751 				;---------------------------------------
  2752 1166			DO_AUTORUN:
  2753 				;---------------------------------------
  2754 				    ; Change URL stored in AUTORUN app key
  2755 				    ;-----------------------------------
  2756 1166 AD 9A 0B		        LDA     CMDSEP          ; Check if there's any arg
  2757 1169 D0 07		        BNE     AUTORUN_NEXT1   ; If arg found, skip ahead
  2758
  2759 				    ; Here if no command line arg found
  2760 				    ; Print error message and exit
  2761 116B A9 B3		        LDA     #<AUTORUN_ERROR_STR
  2762 116D A0 11		        LDY     #>AUTORUN_ERROR_STR
  2763 116F 4C 89 0A		        JMP     PRINT_STRING
  2764
  2765 1172			AUTORUN_NEXT1:
  2766 				    ; Point to start of arg on command line
  2767 1172 18			        CLC
  2768 1173 65 F3		        ADC     INBUFF          ; INBUFF += CMDSEP
  2769 1175 85 F3		        STA     INBUFF
  2770 1177 8D E7 11		        STA     APPKEYWRITEDCB+4
  2771
  2772 				    ; If "AUTORUN ?" Then abuse AUTORUN_SUBMIT to print appkey
  2773 117A A0 00		        LDY     #$00
  2774 117C A9 3F		        LDA     #'?'
  2775 117E 8D 91 18		        STA     AUTORUN_QUERY_FLG
  2776 1181 D1 F3		        CMP     (INBUFF),Y
  2777 1183 F0 6A		        BEQ     SUBMIT_AUTORUN
  2778
  2779 				    ; Open app key
  2780 1185 A9 01		        LDA     #$01            ; Open for write (1)
  2781 1187 8D 91 18		        STA     AUTORUN_QUERY_FLG
  2782 118A 8D BD 11		        STA     AUTORUN_APPKEY+4
  2783 118D A9 CB		        LDA     #<APPKEYOPENDCB
  2784 118F A0 11		        LDY     #>APPKEYOPENDCB
  2785 1191 20 A5 07		        JSR     DOSIOV
  2786
  2787 				    ; Find length of URL (arg1)
  2788 1194 A0 FF		        LDY     #$FF            ; Init strlen
  2789 1196			AUTORUN_LOOP1
  2790 1196 C8			        INY                     ; Incr strlen
  2791 1197 B1 F3		        LDA     (INBUFF),Y
  2792 1199 C9 9B		        CMP     #EOL            ; At end of string?
  2793 119B D0 F9		        BNE     AUTORUN_LOOP1   ; No. Keep counting
  2794
  2795 119D A9 0A		        LDA     #LF             ; Convert EOL to LF
  2796 119F 91 F3		        STA     (INBUFF),Y
  2797 11A1 C8			        INY                     ; One more for strlen
  2798
  2799 11A2			AUTORUN_NEXT2: 
  2800 				    ; Write app key
  2801 11A2 8C ED 11		        STY     APPKEYWRITEDCB+10   ; Y = strlen
  2802 11A5 A9 E3		        LDA     #<APPKEYWRITEDCB
  2803 11A7 A0 11		        LDY     #>APPKEYWRITEDCB
  2804 11A9 20 A5 07		        JSR     DOSIOV
  2805
  2806 				    ; Close app key
  2807 11AC A9 BF		        LDA     #<APPKEYCLOSEDCB
  2808 11AE A0 11		        LDY     #>APPKEYCLOSEDCB
  2809 11B0 4C A5 07		        JMP     DOSIOV
  2810
  2811 11B3			AUTORUN_ERROR_STR:
  2812 11B3 50 41 54 48 3F 9B	        .BYTE   'PATH?',EOL
  2813
  2814 11B9			AUTORUN_APPKEY:
  2815 11B9 79 DB		        .WORD   $DB79           ; creator ID
  2816 11BB 00			        .BYTE   $00             ; app ID
  2817 11BC 00			        .BYTE   $00             ; key ID
  2818 11BD 00			        .BYTE   $00             ; read or write mode
  2819 11BE 00			        .BYTE   $00             ; unused
  2820
  2821 11BF			APPKEYCLOSEDCB:
  2822 11BF 70			        .BYTE   $70             ; DDEVIC
  2823 11C0 01			        .BYTE   $01             ; DUNIT
  2824 11C1 DB			        .BYTE   $DB             ; DCOMND
  2825 11C2 00			        .BYTE   $00             ; DSTATS
  2826 11C3 00			        .BYTE   $00             ; DBUFL
  2827 11C4 00			        .BYTE   $00             ; DBUFH
  2828 11C5 0F			        .BYTE   $0F             ; DTIMLO
  2829 11C6 00			        .BYTE   $00             ; DRESVD
  2830 11C7 00			        .BYTE   $00             ; DBYTL
  2831 11C8 00			        .BYTE   $00             ; DBYTH
  2832 11C9 00			        .BYTE   $00             ; DAUX1
  2833 11CA 00			        .BYTE   $00             ; DAUX2
  2834
  2835 11CB			APPKEYOPENDCB:
  2836 11CB 70			        .BYTE   $70             ; DDEVIC
  2837 11CC 01			        .BYTE   $01             ; DUNIT
  2838 11CD DC			        .BYTE   $DC             ; DCOMND
  2839 11CE 80			        .BYTE   $80             ; DSTATS
  2840 11CF B9			        .BYTE   <AUTORUN_APPKEY ; DBUFL
  2841 11D0 11			        .BYTE   >AUTORUN_APPKEY ; DBUFH
  2842 11D1 0F			        .BYTE   $0F             ; DTIMLO
  2843 11D2 00			        .BYTE   $00             ; DRESVD
  2844 11D3 06			        .BYTE   $06             ; DBYTL
  2845 11D4 00			        .BYTE   $00             ; DBYTH
  2846 11D5 00			        .BYTE   $00             ; DAUX1
  2847 11D6 00			        .BYTE   $00             ; DAUX2
  2848
  2849 11D7			APPKEYREADDCB:
  2850 11D7 70			        .BYTE   $70             ; DDEVIC
  2851 11D8 01			        .BYTE   $01             ; DUNIT
  2852 11D9 DD			        .BYTE   $DD             ; DCOMND
  2853 11DA 40			        .BYTE   $40             ; DSTATS
  2854 11DB 82			        .BYTE   <LNBUF          ; DBUFL
  2855 11DC 05			        .BYTE   >LNBUF          ; DBUFH
  2856 11DD 01			        .BYTE   $01             ; DTIMLO - minimize timeout
  2857 11DE 00			        .BYTE   $00             ; DRESVD
  2858 11DF 40			        .BYTE   MAX_APPKEY_LEN  ; DBYTL
  2859 11E0 00			        .BYTE   $00             ; DBYTH
  2860 11E1 00			        .BYTE   $00             ; DAUX1
  2861 11E2 00			        .BYTE   $00             ; DAUX2
  2862
  2863 11E3			APPKEYWRITEDCB:
  2864 11E3 70			        .BYTE   $70             ; DDEVIC
  2865 11E4 01			        .BYTE   $01             ; DUNIT
  2866 11E5 DE			        .BYTE   $DE             ; DCOMND
  2867 11E6 80			        .BYTE   $80             ; DSTATS
  2868 11E7 FF			        .BYTE   $FF             ; DBUFL
  2869 11E8 05			        .BYTE   $05             ; DBUFH (expect page 5)
  2870 11E9 0F			        .BYTE   $0F             ; DTIMLO
  2871 11EA 00			        .BYTE   $00             ; DRESVD
  2872 11EB 40			        .BYTE   MAX_APPKEY_LEN  ; DBYTL
  2873 11EC 00			        .BYTE   $00             ; DBYTH
  2874 11ED FF			        .BYTE   $FF             ; DAUX1 (# actual bytes)
  2875 11EE 00			        .BYTE   $00             ; DAUX2
  2876
  2877 				;---------------------------------------
  2878 11EF			SUBMIT_AUTORUN:
  2879 				;---------------------------------------
  2880 				    ; At initial DOS boot, read URL for 
  2881 				    ; app key file from SD card's
  2882 				    ; FujiNet folder.
  2883 				    ;
  2884 				    ; filename: db790000.key
  2885 				    ; contents: url to a batch file
  2886 				    ;---------------------------------------
  2887 11EF 20 72 0A		        JSR     LDBUFA
  2888
  2889 				    ; Open app key
  2890 11F2 A9 00		        LDA     #$00            ; Open for read
  2891 11F4 8D BD 11		        STA     AUTORUN_APPKEY+4
  2892 11F7 A9 CB		        LDA     #<APPKEYOPENDCB
  2893 11F9 A0 11		        LDY     #>APPKEYOPENDCB
  2894 11FB 20 A5 07		        JSR     DOSIOV
  2895
  2896 11FE C0 01		        CPY     #$01            ; Was open successful?
  2897 1200 F0 01		        BEQ     AUTOSUB_NEXT    ; Yes. Continue.
  2898 1202 60			        RTS                     ; No. Exit
  2899
  2900 1203			AUTOSUB_NEXT:
  2901 				    ; Read app key
  2902 1203 A9 D7		        LDA     #<APPKEYREADDCB
  2903 1205 A0 11		        LDY     #>APPKEYREADDCB
  2904 1207 20 A5 07		        JSR     DOSIOV
  2905
  2906 				    ; Close app key
  2907 120A A9 BF		        LDA     #<APPKEYCLOSEDCB
  2908 120C A0 11		        LDY     #>APPKEYCLOSEDCB
  2909 120E 20 A5 07		        JSR     DOSIOV
  2910
  2911 				    ; Does the returned URL contain something?
  2912 1211 AE 82 05		        LDX     LNBUF           ; X contains strlen of AUTORUN path
  2913 1214 D0 01		        BNE     AUTORUN_CALL_SUBMIT
  2914
  2915
  2916 1216			AUTOSUB_DONE:
  2917 1216 60			        RTS
  2918
  2919 1217			AUTORUN_CALL_SUBMIT:
  2920 				    ; Replace end-of-line in buffer with null terminator
  2921 1217 CA			        DEX                     ; Move index back 1 position
  2922 1218 A9 00		        LDA     #$00            ;
  2923 121A 9D 84 05		        STA     LNBUF+2,X       ; Write null-terminator 
  2924 121D A9 02		        LDA     #$02            ; Change arg1 location...
  2925 121F 8D 9A 0B		        STA     CMDSEP          ;  to point to filename
  2926
  2927 				    ;---------------------------------------
  2928 				    ; If here because of "AUTORUN ?", then
  2929 				    ; print contents of appkey file. But first
  2930 				    ; we have to terminate appkey string with EOL
  2931 				    ;---------------------------------------
  2932 1222 AD 91 18		        LDA     AUTORUN_QUERY_FLG
  2933 1225 C9 3F		        CMP     #'?'
  2934 1227 D0 18		        BNE     SUBMIT_NEXT1
  2935
  2936 1229 A9 9B		        LDA     #EOL            ; Inject EOL to terminate string
  2937 122B 9D 84 05		        STA     LNBUF+2,X
  2938 122E A9 84		        LDA     #<(LNBUF+2)
  2939 1230 A0 05		        LDY     #>(LNBUF+2)
  2940 1232 4C 89 0A		        JMP     PRINT_STRING    ; Print AUTORUN path and sneak out
  2941
  2942 				;---------------------------------------
  2943 1235			DO_SUBMIT:
  2944 				;---------------------------------------
  2945 1235 AD 9A 0B		        LDA     CMDSEP
  2946 1238 D0 07		        BNE     SUBMIT_NEXT1
  2947
  2948 				    ; Filename required
  2949 123A A9 4A		        LDA     #<MISSING_FILE_STR
  2950 123C A0 17		        LDY     #>MISSING_FILE_STR
  2951 123E 4C 89 0A		        JMP     PRINT_STRING
  2952
  2953 1241			SUBMIT_NEXT1:
  2954
  2955 				    ; Default to NOSCREEN
  2956 1241 A9 00		        LDA     #$00
  2957 1243 8D 53 17		        STA     ECHO_FLG
  2958
  2959 				    ; Prep file path
  2960 1246 20 7D 0C		        JSR     GET_DOSDR       ; Get DUNIT
  2961 1249 20 98 15		        JSR     PREPEND_DRIVE
  2962
  2963 				    ; Assert FILE #1 is closed
  2964 124C A2 10		        LDX     #$10
  2965 124E 20 BB 09		        JSR     CIOCLOSE
  2966 				        
  2967 				    ; OPEN #1, 4, 0, file path
  2968 1251 A2 10		        LDX     #$10            ; File #1
  2969 1253 A0 04		        LDY     #$04            ; Open for input
  2970 1255 20 C3 09		        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  2971 1258 10 03		        BPL     SUBMIT_NEXT2
  2972 125A 4C A4 0A		        JMP     PRINT_ERROR
  2973
  2974 				    ; Read batch file character by character
  2975 				    ; This allows it be end-of-line agnostic
  2976 				    ; Branch forward when an end-of-line is interpretted.
  2977
  2978 125D			SUBMIT_NEXT2:
  2979 125D 20 72 0A		        JSR     LDBUFA      ; Reset INBUFF to $0580
  2980 1260 C6 F3		        DEC     INBUFF      ; Init 1 byte before buffer
  2981 1262 A9 FF		        LDA     #$FF        ; Clear command
  2982 1264 8D 51 17		        STA     CMD
  2983
  2984 1267			SUBMIT_GETCH:
  2985 1267 E6 F3		        INC     INBUFF          ; Advance pointer
  2986 1269 D0 02		        BNE     SUBMIT_NEXT3
  2987 126B E6 F4		        INC     INBUFF+1
  2988
  2989 126D			SUBMIT_NEXT3:
  2990 126D A2 10		        LDX     #$10            ; OPEN #1
  2991 126F A9 01		        LDA     #$01            ; Get 1 byte
  2992 1271 A0 00		        LDY     #$00            ; ditto
  2993
  2994 1273 20 F0 09		        JSR     CIOGET          ; Get byte from file
  2995 1276 A0 00		        LDY     #$00            ;
  2996 1278 B1 F3		        LDA     (INBUFF),Y      ; byte will be here
  2997 				        
  2998 127A C9 0D		        CMP     #CR             ; Just skip if Windows CR
  2999 127C F0 E9		        BEQ     SUBMIT_GETCH
  3000
  3001 127E C9 0A		        CMP     #LF             ; Convert LF to EOL
  3002 1280 D0 04		        BNE     SUBMIT_EOL
  3003 1282 A9 9B		        LDA     #EOL
  3004 1284 91 F3		        STA     (INBUFF),Y
  3005
  3006 1286			SUBMIT_EOL:
  3007 1286 C9 9B		        CMP     #EOL            ; At end of command line?
  3008 1288 D0 DD		        BNE     SUBMIT_GETCH    ; No. Get next byte.
  3009
  3010 				    ; Here if we've reached the end of a command line.
  3011 				    ; At end of file?
  3012 128A A2 10		        LDX     #$10            ; Channel #1
  3013 128C BD 43 03		        LDA     ICSTA,X         ; Inspect return code
  3014 128F C9 88		        CMP     #EOF
  3015 1291 F0 22		        BEQ     SUBMIT_DONE     ; No error, try parsing cmd
  3016
  3017 1293 AD 53 17		        LDA     ECHO_FLG        ; Skip echo if SCREEN is disabled
  3018 1296 F0 11		        BEQ     SUBMIT_NEXT4
  3019 1298 AD 82 05		        LDA     LNBUF
  3020 129B C9 40		        CMP     #'@'            ; Skip lines beginning with @
  3021 129D F0 0A		        BEQ     SUBMIT_NEXT4
  3022
  3023 				    ; Echo commands
  3024 129F 20 72 0A		        JSR     LDBUFA
  3025 12A2 A5 F3		        LDA     INBUFF
  3026 12A4 A4 F4		        LDY     INBUFF+1
  3027 12A6 20 89 0A		        JSR     PRINT_STRING
  3028
  3029 12A9			SUBMIT_NEXT4:
  3030 12A9 20 48 0B		        JSR     GETCMDTEST
  3031 12AC 20 9E 0B		        JSR     PARSECMD
  3032 12AF 20 51 0C		        JSR     DOCMD
  3033 12B2 38			        SEC
  3034 12B3 B0 A8		        BCS     SUBMIT_NEXT2
  3035
  3036 12B5			SUBMIT_DONE
  3037 12B5 A2 10		        LDX     #$10
  3038 12B7 4C BB 09		        JMP     CIOCLOSE
  3039
  3040 				; End of DO_SUBMIT
  3041 				;---------------------------------------
  3042
  3043 				;---------------------------------------
  3044 12BA			DO_TYPE:
  3045 				;---------------------------------------
  3046 12BA AD 9A 0B		        LDA     CMDSEP
  3047 12BD D0 07		        BNE     TYPE_SKIP
  3048
  3049 12BF			TYPE_USAGE:
  3050 12BF A9 4A		        LDA     #<MISSING_FILE_STR
  3051 12C1 A0 17		        LDY     #>MISSING_FILE_STR
  3052 12C3 4C 89 0A		        JMP     PRINT_STRING
  3053
  3054 12C6			TYPE_SKIP:
  3055 12C6 20 7D 0C		        JSR     GET_DOSDR       ; Get DUNIT
  3056 12C9 20 98 15		        JSR     PREPEND_DRIVE
  3057
  3058 				    ; Assert input file closed
  3059 12CC A2 10		        LDX     #$10            ; File #1
  3060 12CE 20 BB 09		        JSR     CIOCLOSE        ; Assert file #1 is closed
  3061
  3062 				    ; Open input file
  3063 12D1 A2 10		        LDX     #$10            ; File #1
  3064 12D3 A0 04		        LDY     #$04            ; Open for input
  3065 12D5 20 C3 09		        JSR     CIOOPEN         ; Open filename @ (INBUFF)
  3066 12D8 10 08		        BPL     TYPE_NEXT
  3067
  3068 				    ; If open failed, Print error
  3069 12DA A2 10		        LDX     #$10            ; File #1
  3070 12DC BC 43 03		        LDY     ICSTA,X
  3071 12DF 4C A4 0A		        JMP     PRINT_ERROR
  3072
  3073 12E2			TYPE_NEXT:
  3074
  3075 				    ; Initialize pagination
  3076 12E2 20 81 13		        JSR     DO_CLS
  3077 12E5 A9 15		        LDA     #21
  3078 12E7 8D BB 02		        STA     SCRFLG
  3079
  3080 12EA			TYPE_LOOP:
  3081 				    ; Bail if ESC key is pressed
  3082 12EA AD FC 02		        LDA     CH
  3083 12ED C9 1C		        CMP     #ESC_KEY
  3084 12EF F0 49		        BEQ     TYPE_DONE
  3085
  3086 				    ; Check if page is full
  3087 12F1 AD BB 02		        LDA     SCRFLG
  3088 12F4 C9 16		        CMP     #22             ; if SCRFLG < 21
  3089 12F6 90 14		        BCC     TYPE_READ       ; then skip to read
  3090
  3091 				    ; Here if page is full
  3092 				    ; Wait for keypress
  3093 12F8 A9 FF		        LDA     #$FF            ; Clear keypress
  3094 12FA 8D FC 02		        STA     CH
  3095
  3096 12FD			TYPE_WAIT:
  3097 12FD AE FC 02		        LDX     CH              ; Will be $FF if no keypress
  3098 1300 E8			        INX                     ; $FF --> $00
  3099 1301 F0 FA		        BEQ     TYPE_WAIT       ; Keep waiting if $00
  3100
  3101 1303 E0 1C		        CPX     #ESC_KEY        ; Leave if ESC key pressed
  3102 1305 F0 33		        BEQ     TYPE_DONE
  3103
  3104 				    ; Reset pagination
  3105 1307 A9 00		        LDA     #$00
  3106 1309 8D BB 02		        STA     SCRFLG
  3107
  3108 130C			TYPE_READ:
  3109 				    ; Read from file
  3110 130C A2 10		        LDX     #$10
  3111 130E A9 01		        LDA     #$01
  3112 1310 A0 00		        LDY     #$00
  3113 1312 20 F0 09		        JSR     CIOGET
  3114
  3115 				    ; Quit if EOF
  3116 1315 A2 10		        LDX     #$10
  3117 1317 BD 43 03		        LDA     ICSTA,X
  3118 131A C9 88		        CMP     #EOF
  3119 131C F0 1C		        BEQ     TYPE_DONE
  3120
  3121 				    ; Convert CRLF or LF --> EOL
  3122 131E A0 00		        LDY     #$00
  3123 1320 B1 F3		        LDA     (INBUFF),Y
  3124 1322 C9 0D		        CMP     #CR     ; Skip CR
  3125 1324 F0 11		        BEQ     TYPE_NEXT3
  3126 1326 C9 0A		        CMP     #LF     ; Convert LF --> EOL
  3127 1328 D0 04		        BNE     TYPE_NEXT2
  3128 132A A9 9B		        LDA     #EOL
  3129 132C 91 F3		        STA     (INBUFF),Y
  3130
  3131 132E			TYPE_NEXT2:
  3132 				    ; Write to screen
  3133 132E A2 00		        LDX     #$00
  3134 1330 A9 01		        LDA     #$01
  3135 1332 A0 00		        LDY     #$00
  3136 1334 20 0E 0A		        JSR     CIOPUT
  3137
  3138 1337			TYPE_NEXT3:
  3139 				    ; Do next
  3140 1337 4C EA 12		        JMP     TYPE_LOOP
  3141 				        
  3142 133A			TYPE_DONE:
  3143 133A A9 FF		        LDA     #$FF
  3144 133C 8D FC 02		        STA     CH
  3145 133F A2 10		        LDX     #$10            ; Close File #1
  3146 1341 4C BB 09		        JMP     CIOCLOSE        ; 
  3147
  3148 1344			TYPE_OPEN_ERR_STR:
  3149 1344 55 4E 41 42 4C 45 +         .BYTE   'UNABLE TO OPEN FILE',EOL
  3150
  3151 				;;---------------------------------------
  3152 				;DO_UNLOCK:
  3153 				;;---------------------------------------
  3154 				;        LDA     #$90
  3155 				;        STA     COLOR2
  3156 				;        RTS
  3157
  3158 				;---------------------------------------
  3159 1358			DO_CAR:
  3160 				;---------------------------------------
  3161
  3162 				    ;---------------------------------------
  3163 				    ; Is cart address space RAM or ROM?
  3164 				    ;---------------------------------------
  3165 1358 AD 00 A0		        LDA     $A000
  3166 135B EE 00 A0		        INC     $A000
  3167 135E CD 00 A0		        CMP     $A000
  3168 1361 F0 0A		        BEQ     DO_CAR_NEXT
  3169
  3170 				    ;---------------------------------------
  3171 				    ; RAM found
  3172 				    ;---------------------------------------
  3173 1363 8D 00 A0		        STA     $A000
  3174 1366 A9 74		        LDA     #<DO_CAR_ERR
  3175 1368 A0 13		        LDY     #>DO_CAR_ERR
  3176 136A 4C 89 0A		        JMP     PRINT_STRING
  3177
  3178 136D			DO_CAR_NEXT:
  3179 136D A9 FF		        LDA     #$FF
  3180 136F 85 08		        STA     $08         ; Warmstart
  3181 1371 6C FA BF		        JMP     ($BFFA)
  3182
  3183 1374			DO_CAR_ERR:
  3184 1374 4E 4F 20 43 41 52 +         .BYTE   'NO CARTRIDGE',EOL
  3185
  3186 				;---------------------------------------
  3187 1381			DO_CLS:
  3188 				;---------------------------------------
  3189 1381 A9 88		        LDA     #<CLS_STR
  3190 1383 A0 13		        LDY     #>CLS_STR
  3191 1385 4C 89 0A		        JMP     PRINT_STRING
  3192
  3193 1388			CLS_STR:
  3194 1388 7D 9B		        .BYTE   125,EOL
  3195
  3196 				;---------------------------------------
  3197 138A			DO_COLD:
  3198 				;---------------------------------------
  3199 138A 4C 77 E4		        JMP     COLDSV
  3200
  3201 				;---------------------------------------
  3202 138D			DO_HELP:
  3203 				;---------------------------------------
  3204 				    ; Append either "HELP" or arg1 to URL
  3205 138D A2 00		        LDX     #$00        ; index to start of article buf
  3206 138F AC 9A 0B		        LDY     CMDSEP      ; index to cmd line arg
  3207 				        
  3208 1392			HELP_LOOP1:
  3209 1392 B1 F3		        LDA     (INBUFF),Y
  3210 1394 C9 9B		        CMP     #EOL
  3211 1396 F0 14		        BEQ     HELP_NEXT1  ; Exit loop at end of arg
  3212 1398 E0 16		        CPX     #22
  3213 139A 10 2E		        BPL     HELP_DONE   ; Exit if arg is too long
  3214
  3215 				    ; Convert lower-case to upper-case
  3216 139C 20 60 0A		        JSR     TOUPPER
  3217 139F 9D 26 14		        STA     HELP_ARTICLE,X
  3218 13A2 E8			        INX
  3219 13A3 C8			        INY
  3220 13A4 D0 EC		        BNE     HELP_LOOP1  ; Always true
  3221
  3222 				    ; Append .DOC extension to article name
  3223 13A6			HELP_EXT:
  3224 13A6 2E 44 4F 43 9B 00	        .BYTE   '.DOC',EOL,$00
  3225
  3226 13AC			HELP_NEXT1:
  3227 13AC A0 00		        LDY     #$00
  3228
  3229 13AE			HELP_LOOP2:
  3230 13AE B9 A6 13		        LDA     HELP_EXT,Y
  3231 13B1 9D 26 14		        STA     HELP_ARTICLE,X  ; Store null term too
  3232 13B4 F0 04		        BEQ     HELP_NEXT2      ; Skip ahead if terminator
  3233 13B6 E8			        INX
  3234 13B7 C8			        INY
  3235 13B8 D0 F4		        BNE     HELP_LOOP2  ; Always true
  3236
  3237 13BA			HELP_NEXT2:
  3238 				    ; Copy URL to LNBUF
  3239 13BA A2 00		        LDX     #$00    ; Index to start of HELP_URL
  3240 13BC A0 05		        LDY     #$05    ; Index to start at arg1 for "TYPE "
  3241 				    
  3242 13BE			HELP_LOOP3:
  3243 13BE BD D2 13		        LDA     HELP_URL,X  ; Get source byte
  3244 13C1 99 82 05		        STA     LNBUF,Y     ; Write to target location
  3245 13C4 F0 04		        BEQ     HELP_DONE   ; Exit loop on null terminator
  3246 13C6 E8			        INX                 ; Advance indices
  3247 13C7 C8			        INY
  3248 13C8 D0 F4		        BNE     HELP_LOOP3  ; Always true
  3249 				        
  3250 13CA			HELP_DONE:        
  3251 13CA A9 05		        LDA     #$05        ; Trick TYPE to look for URL in arg1
  3252 13CC 8D 9A 0B		        STA     CMDSEP
  3253 13CF 4C BA 12		        JMP     DO_TYPE
  3254
  3255 13D2			HELP_URL:
  3256 13D2 4E 38 3A 48 54 54 +         .BYTE   'N8:HTTPS://raw.githubusercontent.com/michaelsternberg/fujinet-nhandler/nos/nos/HELP/'
  3257
  3258 1426			HELP_ARTICLE:
  3259 1426 00 00 00 00 00 00 +     :24 .BYTE   $00
  3260
  3261 				;---------------------------------------
  3262 143E			DO_NOBASIC:
  3263 				;---------------------------------------
  3264 				    ; Quit if 400/800
  3265 143E AD F7 FF		        LDA     $FFF7
  3266 1441 C9 FF		        CMP     #$FF        ; ????
  3267 1443 F0 21		        BEQ     NOBASIC_ERROR
  3268 1445 C9 DD		        CMP     #$DD        ; OSA NTSC
  3269 1447 F0 1D		        BEQ     NOBASIC_ERROR
  3270 1449 C9 F3		        CMP     #$F3        ; OSB NTSC
  3271 144B F0 19		        BEQ     NOBASIC_ERROR
  3272 144D C9 D6		        CMP     #$D6        ; OSA PAL
  3273 144F F0 15		        BEQ     NOBASIC_ERROR
  3274 1451 C9 22		        CMP     #$22        ; OSB PAL
  3275 1453 F0 11		        BEQ     NOBASIC_ERROR
  3276 1455 C9 0A		        CMP     #$0A        ; OSA 1200XL
  3277 1457 F0 0D		        BEQ     NOBASIC_ERROR
  3278 1459 C9 0B		        CMP     #$0B        ; OSB 1200XL
  3279 145B F0 09		        BEQ     NOBASIC_ERROR
  3280 				        
  3281 				    ; Disable BASIC
  3282 145D AD 01 D3		        LDA     PORTB
  3283 1460 09 02		        ORA     #%00000010  ; if Bit 1 = 1 then BASIC is disabled
  3284 1462 8D 01 D3		        STA     PORTB
  3285 1465 60			        RTS
  3286
  3287 				;---------------------------------------
  3288 1466			NOBASIC_ERROR:
  3289 				;---------------------------------------
  3290 1466 A9 6D		        LDA     #<NOBASIC_ERROR_STR
  3291 1468 A0 14		        LDY     #>NOBASIC_ERROR_STR
  3292 146A 4C 89 0A		        JMP     PRINT_STRING
  3293
  3294 146D			NOBASIC_ERROR_STR:
  3295 146D 4E 4F 20 42 55 49 +         .BYTE   'NO BUILT-IN BASIC',EOL
  3296
  3297 				;---------------------------------------
  3298 147F			DO_NOSCREEN:
  3299 				;---------------------------------------
  3300 147F A9 00		        LDA     #$00
  3301 1481 8D 53 17		        STA     ECHO_FLG    ; Disable echo in batch processing
  3302 1484 60			        RTS
  3303
  3304 				;---------------------------------------
  3305 1485			DO_SCREEN:
  3306 				;---------------------------------------
  3307 1485 A9 01		        LDA     #$01
  3308 1487 8D 53 17		        STA     ECHO_FLG    ; Enable echo in batch processing
  3309 148A 60			        RTS
  3310
  3311 				;---------------------------------------
  3312 148B			DO_PRINT:
  3313 				;---------------------------------------
  3314 148B AD 9A 0B		        LDA     CMDSEP
  3315 148E F0 08		        BEQ     PRINT_DONE
  3316
  3317 1490 18			        CLC
  3318 1491 65 F3		        ADC     INBUFF
  3319 1493 A4 F4		        LDY     INBUFF+1
  3320 1495 4C 89 0A		        JMP     PRINT_STRING
  3321
  3322 1498			PRINT_DONE:
  3323 1498 60			        RTS
  3324
  3325 				;---------------------------------------
  3326 1499			DO_REENTER:
  3327 				;---------------------------------------
  3328 				    ; Jump to the address stored in RUNAD or INITAD
  3329 				    ; Do the one that isn't pointing to R (RUNAD first)
  3330
  3331 				    ; Skip it all if both contain $0000
  3332 1499 AD E2 02		        LDA     INITAD
  3333 149C D0 16		        BNE     DO_REENTER_CONT
  3334 149E AD E3 02		        LDA     INITAD+1
  3335 14A1 D0 11		        BNE     DO_REENTER_CONT
  3336 14A3 AD E0 02		        LDA     RUNAD
  3337 14A6 D0 0C		        BNE     DO_REENTER_CONT
  3338 14A8 AD E1 02		        LDA     RUNAD+1
  3339 14AB D0 07		        BNE     DO_REENTER_CONT
  3340
  3341 14AD A9 C8		        LDA     #<DO_REENTER_ERR
  3342 14AF A0 14		        LDY     #>DO_REENTER_ERR
  3343 14B1 4C 89 0A		        JMP     PRINT_STRING
  3344
  3345 14B4			DO_REENTER_CONT:
  3346 14B4 AD E0 02		        LDA     RUNAD
  3347 14B7 C9 0E		        CMP     #>R
  3348 14B9 D0 07		        BNE     DO_REENTER_RUNAD
  3349 14BB AD E1 02		        LDA     RUNAD+1
  3350 14BE C9 0E		        CMP     #>R
  3351 14C0 F0 03		        BEQ     DO_REENTER_INITAD
  3352
  3353 14C2			DO_REENTER_RUNAD:
  3354 14C2 6C E0 02		        JMP     (RUNAD)     ; Godspeed
  3355
  3356 14C5			DO_REENTER_INITAD:
  3357 14C5 6C E2 02		        JMP     (INITAD)    ; Godspeed
  3358
  3359 14C8			DO_REENTER_ERR:
  3360 14C8 4E 4F 20 41 44 44 +         .BYTE   'NO ADDR IN INITAD OR RUNAD',EOL
  3361
  3362 				;---------------------------------------
  3363 14E3			DO_REM:
  3364 				;---------------------------------------
  3365 14E3 60			        RTS
  3366
  3367 				;---------------------------------------
  3368 14E4			DO_RUN:
  3369 				;---------------------------------------
  3370 14E4 AD 9A 0B		        LDA     CMDSEP      ; Get position for address arg
  3371 14E7 A8			        TAY                 ; Offset to arg used later
  3372 14E8 18			        CLC
  3373 14E9 69 04		        ADC     #$04
  3374 14EB 8D 00 18		        STA     RBUF
  3375
  3376 				    ;---------------------------------------
  3377 				    ; ASCII hex char to integer conversion
  3378 				    ; algorithm borrowed from Apple II Monitor
  3379 				    ;---------------------------------------
  3380 14EE A9 00		        LDA     #$00
  3381 14F0 85 F3		        STA     INBUFF      ; L
  3382 14F2 85 F4		        STA     INBUFF+1    ; H
  3383 14F4			NEXTHEX:
  3384 14F4 B9 82 05		        LDA     LNBUF,Y     ; Get character for hex test.
  3385 14F7 49 30		        EOR     #%00110000  ; Maps digits to $0-$9
  3386 14F9 C9 0A		        CMP     #$0A        ; Digit?
  3387 14FB 90 06		        BCC     DIG         ; Yes.
  3388 14FD 69 88		        ADC     #$88        ; Map letter "A"-"F" to $FA-FF.
  3389 14FF C9 FA		        CMP     #$FA        ; Hex letter?
  3390 1501 90 17		        BCC     NOTHEX      ; No, character not hex.
  3391
  3392 1503 0A			DIG:    ASL
  3393 1504 0A			        ASL
  3394 1505 0A			        ASL
  3395 1506 0A			        ASL
  3396 1507 A2 04		        LDX     #$04        ; Shift count.
  3397
  3398 1509			HEXSHIFT:
  3399 1509 0A			        ASL
  3400 150A 26 F3		        ROL     INBUFF      ; Rotate into LSD.
  3401 150C 26 F4		        ROL     INBUFF+1    ; Rotate into MSD's.
  3402 150E CA			        DEX                 ; Done 4 shifts?
  3403 150F D0 F8		        BNE     HEXSHIFT    ; No, loop.
  3404 1511 C8			        INY                 ; Advance text index
  3405 1512 CC 00 18		        CPY     RBUF        ; Processed 4 characters?
  3406 1515 D0 DD		        BNE     NEXTHEX     ; No, get next character.
  3407
  3408 1517 6C F3 00		        JMP     (INBUFF)    ; Goto requested address. Godspeed.
  3409
  3410 151A			NOTHEX:
  3411 151A A9 21		        LDA     #<RUN_ERROR_STR
  3412 151C A0 15		        LDY     #>RUN_ERROR_STR
  3413 151E 4C 89 0A		        JMP     PRINT_STRING
  3414
  3415 1521			RUN_ERROR_STR:
  3416 1521 41 44 44 52 3F 20 +         .BYTE   'ADDR? 0000..FFFF',EOL
  3417
  3418 				;---------------------------------------
  3419 1532			DO_WARM:
  3420 				;---------------------------------------
  3421 1532 4C 74 E4		        JMP     WARMSV
  3422
  3423 				;---------------------------------------
  3424 1535			DO_XEP:
  3425 				;---------------------------------------
  3426 1535 A0 19		        LDY     #$19        ; CMD = $19 (enter 40 col)
  3427 1537 AE 9A 0B		        LDX     CMDSEP
  3428 153A BD 82 05		        LDA     LNBUF,X
  3429 153D C9 34		        CMP     #'4'
  3430 153F F0 01		        BEQ     @+
  3431 1541 88			        DEY                 ; CMD = $18 (enter 80 col)
  3432 				@:      
  3433 1542 A2 00		        LDX     #$00
  3434 1544 98			        TYA
  3435 1545 9D 42 03		        STA     ICCOM,X
  3436 1548 A9 62		        LDA     #<EDEV
  3437 154A 9D 44 03		        STA     ICBAL,X
  3438 154D A9 15		        LDA     #>EDEV
  3439 154F 9D 45 03		        STA     ICBAH,X
  3440 1552 A9 2C		        LDA     #$2C
  3441 1554 9D 4A 03		        STA     ICAX1,X
  3442 1557 A9 00		        LDA     #$00
  3443 1559 9D 4B 03		        STA     ICAX2,X
  3444 155C 20 56 E4		        JSR     CIOV
  3445 155F 4C 81 13		        JMP     DO_CLS
  3446
  3447 1562 25 1A 9B		EDEV:   .BYTE   "E:",EOL
  3448 				        
  3449 				;---------------------------------------
  3450 1565			REMOUNT_DRIVE:
  3451 				;---------------------------------------
  3452
  3453 				    ;---------------------------------------
  3454 				    ; Workaround for timeout issue regarding idempotent commands that
  3455 				    ; unmount the server.  So far, these are DEL and RENAME. This
  3456 				    ; routine, remounts the TNFS URL by calling NPWD and attempts
  3457 				    ; a MKDIR on the returned mount point. Hopefully this is an
  3458 				    ; non-consequential operation since the directory already exists.
  3459 				    ;---------------------------------------
  3460
  3461 1565 20 A0 10		        JSR     DO_NPWD         ; Curr dir for drive now in RBUF
  3462
  3463 1568 AD 00 18		        LDA     RBUF            ; Quit if not TNFS. Only TNFS is affected.
  3464 156B C9 54		        CMP     #'T'            ; TODO More letters needed if...
  3465 156D D0 28		        BNE     REMOUNT_DONE    ; ...another Txxx protocol exists
  3466
  3467 156F A9 4E		        LDA     #'N'
  3468 1571 8D 00 18		        STA     RBUF+0
  3469 1574 AD 50 17		        LDA     DOSDR           ; Get drive number
  3470 1577 09 30		        ORA     #'0'            ; Convert, say, 1 to '1'
  3471 1579 8D 01 18		        STA     RBUF+1
  3472 157C A9 3A		        LDA     #':'
  3473 157E 8D 02 18		        STA     RBUF+2
  3474
  3475 1581 A9 2A		        LDA     #CMD_MKDIR
  3476 1583 8D 0B 0D		        STA     GENDCB+2
  3477 1586 A9 00		        LDA     #<RBUF          ; TODO Is this needed
  3478 1588 8D 0D 0D		        STA     GENDCB+4        ; TODO or is it hardcoded in DO_GENERIC?
  3479 158B A9 18		        LDA     #>RBUF
  3480 158D 8D 0E 0D		        STA     GENDCB+5
  3481
  3482 1590 A9 09		        LDA     #<GENDCB
  3483 1592 A0 0D		        LDY     #>GENDCB
  3484 1594 4C A5 07		        JMP     DOSIOV
  3485
  3486 1597			REMOUNT_DONE:
  3487 1597 60			        RTS
  3488
  3489 				;---------------------------------------
  3490 1598			PREPEND_DRIVE:
  3491 				;---------------------------------------
  3492 				        ; Inject "Nn:" in front of a plain filename
  3493 				        ; before passing it to the FujiNet
  3494 1598 A0 00		        LDY     #$00
  3495 159A A9 4E		        LDA     #'N'
  3496 159C D1 F3		        CMP     (INBUFF),Y  ; Does arg1 already begin with N?
  3497
  3498 159E A0 02		        LDY     #$02
  3499 15A0 A9 3A		        LDA     #':'
  3500 15A2 D1 F3		        CMP     (INBUFF),Y
  3501 15A4 F0 1C		        BEQ     PREPEND_DRIVE_DONE
  3502 15A6 88			        DEY
  3503 15A7 D1 F3		        CMP     (INBUFF),Y
  3504 15A9 F0 17		        BEQ     PREPEND_DRIVE_DONE
  3505
  3506 				        ; Move input buffer pointer back 3 bytes
  3507 15AB 38			        SEC
  3508 15AC A5 F3		        LDA     INBUFF
  3509 15AE E9 03		        SBC     #$03
  3510 15B0 85 F3		        STA     INBUFF
  3511 15B2 A5 F4		        LDA     INBUFF+1
  3512 15B4 E9 00		        SBC     #$00
  3513 15B6 85 F4		        STA     INBUFF+1
  3514
  3515 				        ; Inject PRMPT to front of arg1
  3516 15B8 A0 03		        LDY     #$03
  3517 15BA			PREPEND_DRIVE_LOOP:
  3518 15BA B9 EC 15		        LDA     PRMPT,Y
  3519 15BD 88			        DEY
  3520 15BE 91 F3		        STA     (INBUFF),Y
  3521 15C0 D0 F8		        BNE     PREPEND_DRIVE_LOOP
  3522
  3523 15C2			PREPEND_DRIVE_DONE:
  3524 15C2 A0 01		        LDY     #$01
  3525 15C4 60			        RTS             ; Y = $00 here
  3526
  3527 				;---------------------------------------
  3528 15C5			APPEND_SLASH:
  3529 				;---------------------------------------
  3530 				    ;---------------------------------------
  3531 				    ; Skip if relative path (..)
  3532 				    ;---------------------------------------
  3533 15C5 A0 00		        LDY     #$00
  3534 15C7 A9 2E		        LDA     #'.'
  3535 15C9 D1 F3		        CMP     (INBUFF),Y
  3536 15CB F0 1E		        BEQ     APPEND_SLASH_DONE
  3537
  3538 15CD A0 FF		        LDY     #$FF        ; Iterate thru arg2 until EOF
  3539 15CF			APPEND_SLASH_LOOP:
  3540 15CF C8			        INY                 ; Zero on 1st pass
  3541 15D0 B1 F3		        LDA     (INBUFF),Y
  3542 15D2 C9 9B		        CMP     #EOL
  3543 15D4 D0 F9		        BNE     APPEND_SLASH_LOOP
  3544
  3545 15D6 88			        DEY                 ; Move pointer back one character
  3546 15D7 B1 F3		        LDA     (INBUFF),Y
  3547 15D9 C9 2F		        CMP     #'/'        ; If already slash then skip rest
  3548 15DB F0 0E		        BEQ     APPEND_SLASH_DONE
  3549 15DD C9 3A		        CMP     #':'        ; If a drive, skip
  3550 15DF F0 0A		        BEQ     APPEND_SLASH_DONE
  3551
  3552 15E1 C8			        INY                 ; Else inject '/' + EOL
  3553 15E2 A9 2F		        LDA     #'/'
  3554 15E4 91 F3		        STA     (INBUFF),Y
  3555 15E6 C8			        INY
  3556 15E7 A9 9B		        LDA     #EOL
  3557 15E9 91 F3		        STA     (INBUFF),Y
  3558
  3559 15EB			APPEND_SLASH_DONE:
  3560 15EB 60			        RTS
  3561
  3562 15EC			PRMPT:
  3563 15EC 9B 4E 20 3A		        .BYTE   EOL,'N :'
  3564
  3565 				;;; End CP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  3566 				;;; Variables
  3567
  3568 15F0			        .ENUM   CMD_IDX
  3569 				        ;---------------
  3570 = 0000			                NCD                 ;  0
  3571 				;               COPY                ;  1
  3572 = 0001			                DIR                 ;  2
  3573 = 0002			                DEL                 ;  3
  3574 = 0003			                LOAD                ;  4
  3575 				;               LOCK                ;  5
  3576 = 0004			                LPR                 ;  6
  3577 = 0005			                MKDIR               ;  7
  3578 = 0006			                NPWD                ;  8
  3579 = 0007			                NTRANS              ;  9
  3580 = 0008			                PASS                ; 10
  3581 = 0009			                RENAME              ; 11
  3582 = 000A			                RMDIR               ; 12
  3583 = 000B			                SUBMIT              ; 13
  3584 = 000C			                TYPE                ; 14
  3585 = 000D			                USER                ; 15
  3586 				;               UNLOCK              ; 16
  3587 = 000E			                AUTORUN             ; 17
  3588 = 000F			                CAR                 ; 18
  3589 = 0010			                CLS                 ; 19
  3590 = 0011			                COLD                ; 10
  3591 = 0012			                HELP                ; 21
  3592 = 0013			                NOBASIC             ; 22
  3593 = 0014			                NOSCREEN            ; 23
  3594 = 0015			                PRINT               ; 24
  3595 = 0016			                REENTER             ; 25
  3596 = 0017			                REM                 ; 26
  3597 = 0018			                RUN                 ; 27
  3598 = 0019			                SCREEN              ; 28
  3599 = 001A			                WARM                ; 29
  3600 = 001B			                XEP                 ; 30
  3601 = 001C			                DRIVE_CHG           ; 31
  3602 				        .ENDE
  3603
  3604 15F0			CMD_DCOMND:
  3605 15F0 2C			        .BYTE   CMD_CD              ;  0 NCD
  3606 				;       .BYTE   CMD_COPY            ;  1 COPY
  3607 15F1 02			        .BYTE   CMD_DIR             ;  2 DIR
  3608 15F2 21			        .BYTE   CMD_DEL             ;  3 DEL
  3609 15F3 28			        .BYTE   CMD_LOAD            ;  4 LOAD
  3610 				;       .BYTE   CMD_LOCK            ;  5 LOCK
  3611 15F4 F0			        .BYTE   CMD_LPR             ;  6 LPR
  3612 15F5 2A			        .BYTE   CMD_MKDIR           ;  7 MKDIR
  3613 15F6 30			        .BYTE   CMD_NPWD            ;  8 NPWD
  3614 15F7 54			        .BYTE   CMD_NTRANS          ;  9 NTRANS
  3615 15F8 FE			        .BYTE   CMD_PASS            ; 10 PASS
  3616 15F9 20			        .BYTE   CMD_RENAME          ; 11 RENAME
  3617 15FA 2B			        .BYTE   CMD_RMDIR           ; 12 RMDIR
  3618 15FB F0			        .BYTE   CMD_SUBMIT          ; 13 SUBMIT
  3619 15FC F0			        .BYTE   CMD_TYPE            ; 14 TYPE
  3620 15FD FD			        .BYTE   CMD_USER            ; 15 USER
  3621 				;       .BYTE   CMD_UNLOCK          ; 16 UNLOCK
  3622 15FE F0			        .BYTE   CMD_AUTORUN         ; 17 AUTORUN
  3623 15FF F0			        .BYTE   CMD_CAR             ; 18 CAR
  3624 1600 F0			        .BYTE   CMD_CLS             ; 19 CLS
  3625 1601 F0			        .BYTE   CMD_COLD            ; 10 COLD
  3626 1602 F0			        .BYTE   CMD_HELP            ; 21 HELP
  3627 1603 F0			        .BYTE   CMD_NOBASIC         ; 22 NOBASIC
  3628 1604 F0			        .BYTE   CMD_NOSCREEN        ; 23 NOSCREEN
  3629 1605 F0			        .BYTE   CMD_PRINT           ; 24 PRINT
  3630 1606 F0			        .BYTE   CMD_REENTER         ; 25 REENTER
  3631 1607 F0			        .BYTE   CMD_REM             ; 26 REM
  3632 1608 F0			        .BYTE   CMD_RUN             ; 27 RUN
  3633 1609 F0			        .BYTE   CMD_SCREEN          ; 28 SCREEN
  3634 160A F0			        .BYTE   CMD_WARM            ; 29 WARM
  3635 160B F0			        .BYTE   CMD_XEP             ; 30 XEP
  3636 160C 01			        .BYTE   CMD_DRIVE_CHG       ; 31
  3637
  3638 160D			COMMAND:
  3639 160D 4E 43 C4		        .CB     "NCD"               ;  0 NCD
  3640 1610 00			        .BYTE   CMD_IDX.NCD            
  3641
  3642 				;       .CB     "COPY"              ;  1 COPY
  3643 				;       .BYTE   CMD_IDX.COPY           
  3644
  3645 1611 44 49 D2		        .CB     "DIR"               ;  2 DIR
  3646 1614 01			        .BYTE   CMD_IDX.DIR              
  3647
  3648 1615 44 45 CC		        .CB     "DEL"               ;  3 DEL
  3649 1618 02			        .BYTE   CMD_IDX.DEL              
  3650
  3651 1619 4C 4F 41 C4		        .CB     "LOAD"              ;  4 LOAD
  3652 161D 03			        .BYTE   CMD_IDX.LOAD             
  3653
  3654 				;       .CB     "LOCK"              ;  5 LOCK
  3655 				;       .BYTE   CMD_IDX.LOCK             
  3656
  3657 161E 4C 50 D2		        .CB     "LPR"               ;  6 LPR
  3658 1621 04			        .BYTE   CMD_IDX.LPR              
  3659 				                                        
  3660 1622 4D 4B 44 49 D2	        .CB     "MKDIR"             ;  7 MKDIR
  3661 1627 05			        .BYTE   CMD_IDX.MKDIR           
  3662 				                                        
  3663 1628 4E 50 57 C4		        .CB     "NPWD"              ;  8 NPWD
  3664 162C 06			        .BYTE   CMD_IDX.NPWD             
  3665 				                                        
  3666 162D 4E 54 52 41 4E D3	        .CB     "NTRANS"            ;  9 NTRANS
  3667 1633 07			        .BYTE   CMD_IDX.NTRANS            
  3668 				                                        
  3669 1634 50 41 53 D3		        .CB     "PASS"              ; 10 PASS
  3670 1638 08			        .BYTE   CMD_IDX.PASS             
  3671 				                                         
  3672 1639 52 45 4E 41 4D C5	        .CB     "RENAME"            ; 11 RENAME
  3673 163F 09			        .BYTE   CMD_IDX.RENAME          
  3674 				                                        
  3675 1640 52 4D 44 49 D2	        .CB     "RMDIR"             ; 12 RMDIR
  3676 1645 0A			        .BYTE   CMD_IDX.RMDIR           
  3677 				                                        
  3678 1646 53 55 42 4D 49 D4	        .CB     "SUBMIT"            ; 13 SUBMIT
  3679 164C 0B			        .BYTE   CMD_IDX.SUBMIT             
  3680 				                                        
  3681 164D 54 59 50 C5		        .CB     "TYPE"              ; 14 TYPE
  3682 1651 0C			        .BYTE   CMD_IDX.TYPE                
  3683 				                                          
  3684 1652 55 53 45 D2		        .CB     "USER"             ;  15 USER
  3685 1656 0D			        .BYTE   CMD_IDX.USER              
  3686 				                                        
  3687 				;       .CB     "UNLOCK"            ; 16 UNLOCK
  3688 				;       .BYTE   CMD_IDX.UNLOCK            
  3689 				                                        
  3690 1657 41 55 54 4F 52 55 +         .CB     "AUTORUN"           ; 17 AUTORUN
  3691 165E 0E			        .BYTE   CMD_IDX.AUTORUN           
  3692 				                                          
  3693 165F 43 41 D2		        .CB     "CAR"               ; 18 CAR
  3694 1662 0F			        .BYTE   CMD_IDX.CAR             
  3695 				                                       
  3696 1663 43 4C D3		        .CB     "CLS"               ; 19 CLS
  3697 1666 10			        .BYTE   CMD_IDX.CLS             
  3698 				                                        
  3699 1667 43 4F 4C C4		        .CB     "COLD"              ; 10 COLD
  3700 166B 11			        .BYTE   CMD_IDX.COLD              
  3701 				                                        
  3702 166C 48 45 4C D0		        .CB     "HELP"              ; 21 HELP
  3703 1670 12			        .BYTE   CMD_IDX.HELP               
  3704 				                                        
  3705 1671 4E 4F 42 41 53 49 +         .CB     "NOBASIC"           ; 22 NOBASIC
  3706 1678 13			        .BYTE   CMD_IDX.NOBASIC           
  3707 				                                          
  3708 1679 40 4E 4F 53 43 52 +         .CB     "@NOSCREEN"         ; 23 @NOSCREEN
  3709 1682 14			        .BYTE   CMD_IDX.NOSCREEN         
  3710 				                                        
  3711 1683 50 52 49 4E D4	        .CB     "PRINT"             ; 24 PRINT
  3712 1688 15			        .BYTE   CMD_IDX.PRINT           
  3713 				                                        
  3714 1689 52 45 45 4E 54 45 +         .CB     "REENTER"           ; 25 REENTER
  3715 1690 16			        .BYTE   CMD_IDX.REENTER         
  3716 				                                        
  3717 1691 52 45 CD		        .CB     "REM"               ; 26 REM
  3718 1694 17			        .BYTE   CMD_IDX.REM             
  3719 				                                        
  3720 1695 52 55 CE		        .CB     "RUN"               ; 27 RUN
  3721 1698 18			        .BYTE   CMD_IDX.RUN             
  3722 				                                        
  3723 1699 40 53 43 52 45 45 +         .CB     "@SCREEN"           ; 28 @SCREEN
  3724 16A0 19			        .BYTE   CMD_IDX.SCREEN          
  3725 				                                        
  3726 16A1 57 41 52 CD		        .CB     "WARM"              ; 29 WARM
  3727 16A5 1A			        .BYTE   CMD_IDX.WARM          
  3728 				                                      
  3729 16A6 58 45 D0		        .CB     "XEP"               ; 30 XEP
  3730 16A9 1B			        .BYTE   CMD_IDX.XEP            
  3731 				                                        
  3732 				; Aliases
  3733 16AA 43 C4		        .CB     "CD"                ; CD = NCD
  3734 16AC 00			        .BYTE   CMD_IDX.NCD           
  3735
  3736 16AD 43 57 C4		        .CB     "CWD"               ; CWD = NCD
  3737 16B0 00			        .BYTE   CMD_IDX.NCD           
  3738
  3739 16B1 45 52 41 53 C5	        .CB     "ERASE"             ; ERASE = DEL
  3740 16B6 02			        .BYTE   CMD_IDX.DEL           
  3741
  3742 16B7 45 52 C1		        .CB     "ERA"               ; ERA = DEL
  3743 16BA 02			        .BYTE   CMD_IDX.DEL           
  3744
  3745 16BB D8			        .CB     "X"                 ; X = LOAD
  3746 16BC 03			        .BYTE   CMD_IDX.LOAD
  3747
  3748 16BD 50 57 C4		        .CB     "PWD"               ; PWD = NPWD
  3749 16C0 06			        .BYTE   CMD_IDX.NPWD             
  3750
  3751 16C1 52 45 C5		        .CB     "REE"               ; R = REENTER
  3752 16C4 16			        .BYTE   CMD_IDX.REENTER             
  3753
  3754 16C5 52 45 CE		        .CB     "REN"               ; REN = RENAME
  3755 16C8 09			        .BYTE   CMD_IDX.RENAME
  3756
  3757 16C9 53 4F 55 52 43 C5	        .CB     "SOURCE"            ; SOURCE = SUBMIT
  3758 16CF 0B			        .BYTE   CMD_IDX.SUBMIT
  3759
  3760 16D0 C0			        .CB     "@"                 ; @ = SUBMIT
  3761 16D1 0B			        .BYTE   CMD_IDX.SUBMIT
  3762
  3763 16D2 A3			        .CB     "#"                 ; # = REM
  3764 16D3 17			        .BYTE   CMD_IDX.REM
  3765
  3766 16D4 A7			        .CB     "'"                 ; ' = REM
  3767 16D5 17			        .BYTE   CMD_IDX.REM
  3768
  3769 				        ; Drive Change intentionally omitted
  3770
  3771 = 00C8			COMMAND_SIZE = * - COMMAND - 1
  3772 16D6 FF			        .BYTE   $FF
  3773
  3774 16D7			CMD_TAB_L:
  3775 16D7 9F			        .BYTE   <(DO_GENERIC-1)     ;  0 NCD
  3776 				;       .BYTE   <(DO_COPY-1)        ;  1 COPY
  3777 16D8 14			        .BYTE   <(DO_DIR-1)         ;  2 DIR
  3778 16D9 9F			        .BYTE   <(DO_GENERIC-1)     ;  3 DEL
  3779 16DA FE			        .BYTE   <(DO_LOAD-1)        ;  4 LOAD
  3780 				;       .BYTE   <(DO_LOCK-1)        ;  5 LOCK
  3781 16DB 99			        .BYTE   <(DO_LPR-1)         ;  6 LPR
  3782 16DC 9F			        .BYTE   <(DO_GENERIC-1)     ;  7 MKDIR
  3783 16DD 9F			        .BYTE   <(DO_NPWD-1)        ;  8 NPWD
  3784 16DE E2			        .BYTE   <(DO_NTRANS-1)      ;  9 NTRANS
  3785 16DF 9F			        .BYTE   <(DO_GENERIC-1)     ; 10 PASS
  3786 16E0 9F			        .BYTE   <(DO_GENERIC-1)     ; 11 RENAME
  3787 16E1 9F			        .BYTE   <(DO_GENERIC-1)     ; 12 RMDIR
  3788 16E2 34			        .BYTE   <(DO_SUBMIT-1)      ; 13 SUBMIT
  3789 16E3 B9			        .BYTE   <(DO_TYPE-1)        ; 14 TYPE
  3790 16E4 9F			        .BYTE   <(DO_GENERIC-1)     ; 15 USER
  3791 				;       .BYTE   <(DO_UNLOCK-1)      ; 16 UNLOCK
  3792 16E5 65			        .BYTE   <(DO_AUTORUN-1)     ; 17 AUTORUN
  3793 16E6 57			        .BYTE   <(DO_CAR-1)         ; 18 CAR
  3794 16E7 80			        .BYTE   <(DO_CLS-1)         ; 19 CLS
  3795 16E8 89			        .BYTE   <(DO_COLD-1)        ; 10 COLD
  3796 16E9 8C			        .BYTE   <(DO_HELP-1)        ; 21 HELP
  3797 16EA 3D			        .BYTE   <(DO_NOBASIC-1)     ; 22 NOBASIC
  3798 16EB 7E			        .BYTE   <(DO_NOSCREEN-1)    ; 23 NOSCREEN
  3799 16EC 8A			        .BYTE   <(DO_PRINT-1)       ; 24 PRINT
  3800 16ED 98			        .BYTE   <(DO_REENTER-1)     ; 25 REENTER
  3801 16EE E2			        .BYTE   <(DO_REM-1)         ; 26 REM
  3802 16EF E3			        .BYTE   <(DO_RUN-1)         ; 27 RUN
  3803 16F0 84			        .BYTE   <(DO_SCREEN-1)      ; 28 SCREEN
  3804 16F1 31			        .BYTE   <(DO_WARM-1)        ; 29 WARM
  3805 16F2 34			        .BYTE   <(DO_XEP-1)         ; 30 XEP
  3806 16F3 5E			        .BYTE   <(DO_DRIVE_CHG-1)   ; 31
  3807
  3808 16F4			CMD_TAB_H:
  3809 16F4 0C			        .BYTE   >(DO_GENERIC-1)     ;  0 NCD
  3810 				;       .BYTE   >(DO_COPY-1)        ;  1 COPY
  3811 16F5 0D			        .BYTE   >(DO_DIR-1)         ;  2 DIR
  3812 16F6 0C			        .BYTE   >(DO_GENERIC-1)     ;  3 DEL
  3813 16F7 0D			        .BYTE   >(DO_LOAD-1)        ;  4 LOAD
  3814 				;       .BYTE   >(DO_LOCK-1)        ;  5 LOCK
  3815 16F8 10			        .BYTE   >(DO_LPR-1)         ;  6 LPR
  3816 16F9 0C			        .BYTE   >(DO_GENERIC-1)     ;  7 MKDIR
  3817 16FA 10			        .BYTE   >(DO_NPWD-1)        ;  8 NPWD
  3818 16FB 10			        .BYTE   >(DO_NTRANS-1)      ;  9 NTRANS
  3819 16FC 0C			        .BYTE   >(DO_GENERIC-1)     ; 10 PASS
  3820 16FD 0C			        .BYTE   >(DO_GENERIC-1)     ; 11 RENAME
  3821 16FE 0C			        .BYTE   >(DO_GENERIC-1)     ; 12 RMDIR
  3822 16FF 12			        .BYTE   >(DO_SUBMIT-1)      ; 13 SUBMIT
  3823 1700 12			        .BYTE   >(DO_TYPE-1)        ; 14 TYPE
  3824 1701 0C			        .BYTE   >(DO_GENERIC-1)     ; 15 USER
  3825 				;       .BYTE   >(DO_UNLOCK-1)      ; 16 UNLOCK
  3826 1702 11			        .BYTE   >(DO_AUTORUN-1)     ; 17 AUTORUN
  3827 1703 13			        .BYTE   >(DO_CAR-1)         ; 18 CAR
  3828 1704 13			        .BYTE   >(DO_CLS-1)         ; 19 CLS
  3829 1705 13			        .BYTE   >(DO_COLD-1)        ; 20 COLD
  3830 1706 13			        .BYTE   >(DO_HELP-1)        ; 21 HELP
  3831 1707 14			        .BYTE   >(DO_NOBASIC-1)     ; 22 NOBASIC
  3832 1708 14			        .BYTE   >(DO_NOSCREEN-1)    ; 23 NOSCREEN
  3833 1709 14			        .BYTE   >(DO_PRINT-1)       ; 24 PRINT
  3834 170A 14			        .BYTE   >(DO_REENTER-1)     ; 25 REENTER
  3835 170B 14			        .BYTE   >(DO_REM-1)         ; 26 REM
  3836 170C 14			        .BYTE   >(DO_RUN-1)         ; 27 RUN
  3837 170D 14			        .BYTE   >(DO_SCREEN-1)      ; 28 SCREEN
  3838 170E 15			        .BYTE   >(DO_WARM-1)        ; 29 WARM
  3839 170F 15			        .BYTE   >(DO_XEP-1)         ; 30 XEP
  3840 1710 0C			        .BYTE   >(DO_DRIVE_CHG-1)   ; 31
  3841
  3842 				        ; DEVHDL TABLE FOR N:
  3843
  3844 1711 BD 07		CIOHND  .WORD   OPEN-1
  3845 1713 0B 08		        .WORD   CLOSE-1
  3846 1715 2C 08		        .WORD   GET-1
  3847 1717 8D 08		        .WORD   PUT-1
  3848 1719 ED 08		        .WORD   STATUS-1
  3849 171B 53 09		        .WORD   SPEC-1
  3850
  3851 				       ; BANNERS
  3852
  3853 171D 23 46 55 4A 49 4E + BREADY  .BYTE   '#FUJINET NOS v0.5.0-alpha',EOL
  3854 1737 23 46 55 4A 49 4E + BERROR  .BYTE   '#FUJINET ERROR',EOL
  3855
  3856 				        ; MESSAGES
  3857
  3858 1746 4E 23 3F 9B		CDERR   .BYTE   'N#?',EOL
  3859
  3860 				        ; STRING CONSTANTS
  3861
  3862 174A			MISSING_FILE_STR:
  3863 174A 46 49 4C 45 3F 9B	        .BYTE   'FILE?',EOL
  3864
  3865 				        ; VARIABLES
  3866
  3867 1750 01			DOSDR       .BYTE   $01     ; DOS DRIVE
  3868 1751 01			CMD         .BYTE   $01
  3869 1752 01			CMDPRV      .BYTE   $01
  3870 1753 01			ECHO_FLG    .BYTE   $01     ; Echo batch cmds (1=enabled,0=disabled)
  3871 1754 00			AUTORUN_FLG .BYTE   $00     ; Checked at DOS entry. Runs only on first pass
  3872
  3873 1755 01			TRIP    .BYTE   $01         ; INTR FLAG
  3874 1756 00 00 00 00		RLEN    :MAXDEV .BYTE $00   ; RCV LEN
  3875 175A 00 00 00 00		ROFF    :MAXDEV .BYTE $00   ; RCV OFFSET
  3876 175E 00 00 00 00		TOFF    :MAXDEV .BYTE $00   ; TRX OFFSET
  3877 1762 01			INQDS   .BYTE   $01         ; DSTATS INQ
  3878
  3879 1763 00 00 00 00		DVS2    :MAXDEV .BYTE $00   ; DVSTAT+2 SAVE
  3880 1767 00 00 00 00		DVS3    :MAXDEV .BYTE $00   ; DVSTAT+3 SAVE
  3881
  3882 				       ; BUFFERS (PAGE ALIGNED)
  3883 176B 00 00 00 00 00 00 +         .ALIGN  $100, $00
  3884 1800			BOOTEND:
  3885
  3886 1800 00 00 00 00 00 00 + RBUF:   :$80 .BYTE $00      ; 128 bytes
  3887 1880 00 00 00 00 00 00 + TBUF:   :$80 .BYTE $00      ; 128 bytes
  3888
  3889 				; Binary loader working variables
  3890 = 1800			BAL     = RBUF
  3891 = 1801			BAH     = RBUF+1    ;
  3892 = 1880			STL     = TBUF      ; Payload Start address
  3893 = 1881			STH     = TBUF+1
  3894 = 1882			ENL     = TBUF+2    ; Payload End address
  3895 = 1883			ENH     = TBUF+3
  3896 = 1884			BLL     = TBUF+4    ; Payload Buffer Length
  3897 = 1885			BLH     = TBUF+5
  3898 = 1886			HEADL   = TBUF+6    ; Bytes read from existing cache
  3899 = 1887			HEADH   = TBUF+7
  3900 = 1888			BODYL   = TBUF+8    ; Total bytes read in contiguous 512-byte blocks
  3901 = 1889			BODYH   = TBUF+9
  3902 = 188A			TAILL   = TBUF+10   ; Bytes read from last cache
  3903 = 188B			TAILH   = TBUF+11
  3904 = 188C			BODYSZL = TBUF+12   ; # Bytes to read at a time in Body
  3905 = 188D			BODYSZH = TBUF+13
  3906 = 188E			STL2    = TBUF+14   ; Payload Start address (working var)
  3907 = 188F			STH2    = TBUF+15
  3908 = 1890			BIN_1ST = TBUF+16   ; Flag for binary loader signature (FF -> 1st pass)
  3909 = 1891			AUTORUN_QUERY_FLG = TBUF+17   ; Flag for printing contents of autorun appkey
  3910
  3911 = 1900			PGEND   = *
  3912
  3913 				; =================================================================
  3914 				; VTOC and Directory
  3915 				;
  3916
  3917 				; $10 is the added ATR-header
  3918 1900 00 00 00 00 00 00 + :($B390-*+HDR-$10) DTA $00
  3919 BA80			VTOCSTA:
  3920 BA80 02 BD 02		    DTA $02,$BD,$02
  3921 BA83			VTOCEND:
  3922
  3923 				; Fill the remaining bytes of the VTOC sector
  3924 BA83 00 00 00 00 00 00 +     :($80+VTOCSTA-VTOCEND) DTA $00
  3925
  3926 BB00			DIRSTA:
  3927 BB00 60 C3 02 04 00 30 +     DTA $60,$C3,$02,$04,$00,C"0**********"
  3928 BB10 60 C3 02 04 00 31 +     DTA $60,$C3,$02,$04,$00,C"1 FujiNet  "
  3929 BB20 60 C3 02 04 00 32 +     DTA $60,$C3,$02,$04,$00,C"2 Network  "
  3930 BB30 60 C3 02 04 00 33 +     DTA $60,$C3,$02,$04,$00,C"3   OS     "
  3931 BB40 60 C3 02 04 00 34 +     DTA $60,$C3,$02,$04,$00,C"4          "
  3932 BB50 60 C3 02 04 00 35 +     DTA $60,$C3,$02,$04,$00,C"5 v0.5.0   "
  3933 BB60 60 C3 02 04 00 36 +     DTA $60,$C3,$02,$04,$00,C"6  alpha   "
  3934 BB70 60 C3 02 04 00 37 +     DTA $60,$C3,$02,$04,$00,C"7**********"
  3935 BB80 C0			    DTA $C0
  3936 BB81			DIREND:
  3937
  3938 				; Fill the remaining sectors of the directory
  3939 BB81 00 00 00 00 00 00 +     :($400+DIRSTA-DIREND) DTA $00
  3940
  3941 				; Sectors behind directory
  3942 BF00 00 00 00 00 00 00 +     :($80*352) DTA $00
  3943
  3944 				       END
